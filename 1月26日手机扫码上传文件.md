# 手机扫码上传文件功能详细流程

## 一、功能概述

手机扫码上传文件功能允许用户通过手机浏览器扫描二维码，将手机中的文件上传到系统中，无需在电脑上准备文件。该功能适用于需要从手机中快速上传图片、文档等文件的场景。

## 二、技术架构

### 1. 前端技术栈
- Vue 3 + TypeScript
- Element Plus UI组件库
- qrcode.vue：生成二维码
- Sortable.js：文件拖拽排序
- @vben/request：API请求

### 2. 后端技术栈
- Java Spring Boot
- RESTful API
- WebSocket（可选，用于实时通知）
- 文件存储服务

## 三、详细流程

### 1. 前端流程

#### 1.1 打开手机上传对话框

**触发条件**：用户在新增或编辑窗口中点击"手机上传"按钮

**实现代码**：
```vue
<ElButton type="success" @click="openMobileUploadDialog">
  <Icon icon="lucide:smartphone" class="mr-1" />
  手机上传
</ElButton>
```

**核心逻辑**：
- 生成唯一的上传会话ID
- 构建手机上传URL，包含会话ID和案例ID
- 生成二维码
- 设置二维码过期时间（5分钟）
- 打开二维码弹窗
- 开始轮询检查上传状态

#### 1.2 生成二维码

**实现代码**：
```typescript
const openMobileUploadDialog = () => {
  // 生成随机的上传会话ID
  const uploadSessionId = `upload_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  
  // 生成二维码URL
  const baseUrl = window.location.origin;
  const mobileUploadUrl = `${baseUrl}/mobile-upload?sessionId=${uploadSessionId}&caseId=${props.caseId}`;
  
  qrCodeUrl.value = mobileUploadUrl;
  qrCodeExpireTime.value = 300; // 5分钟过期
  showQrCodeDialog.value = true;
  
  // 开始轮询检查上传状态
  startQrCodePolling(uploadSessionId);
};
```

**二维码内容**：
```
https://example.com/mobile-upload?sessionId=upload_1706234567890_abc123&caseId=12345
```

#### 1.3 轮询检查上传状态

**实现代码**：
```typescript
const startQrCodePolling = (sessionId: string) => {
  // 每3秒轮询一次
  qrCodePolling.value = setInterval(async () => {
    try {
      // 调用后端API检查上传状态
      const response = await requestClient8085.get(`/upload/status/${sessionId}`);
      
      if (response.code === 200 && response.data) {
        const { status, files } = response.data;
        
        if (status === 'COMPLETED' && files.length > 0) {
          // 上传完成，更新文件列表
          updateFileList(files);
          // 关闭二维码弹窗
          showQrCodeDialog.value = false;
          // 清除轮询
          clearInterval(qrCodePolling.value!);
        }
      }
      
      // 检查二维码是否过期
      if (qrCodeExpireTime.value <= 0) {
        clearInterval(qrCodePolling.value!);
        ElMessage.warning('二维码已过期，请重新生成');
        showQrCodeDialog.value = false;
      }
      
      qrCodeExpireTime.value--;
    } catch (error) {
      console.error('轮询上传状态失败:', error);
    }
  }, 3000);
};
```

**轮询频率**：3秒/次

**过期处理**：5分钟后二维码过期，自动关闭弹窗

### 2. 手机端流程

#### 2.1 扫描二维码

**操作步骤**：
1. 打开手机浏览器
2. 点击浏览器的"扫一扫"功能
3. 对准电脑屏幕上的二维码进行扫描
4. 手机浏览器自动打开上传页面

**支持的浏览器**：
- Chrome（推荐）
- Safari
- Edge
- Firefox

#### 2.2 手机端上传页面

**页面功能**：
- 显示上传会话信息
- 提供文件选择按钮
- 显示上传进度
- 支持多文件上传
- 支持取消上传

**核心HTML**：
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手机上传文件</title>
</head>
<body>
    <div class="upload-container">
        <h1>手机上传文件</h1>
        <p>会话ID：<span id="sessionId"></span></p>
        <input type="file" id="fileInput" multiple>
        <button id="uploadBtn">开始上传</button>
        <div id="progressContainer"></div>
        <div id="fileList"></div>
    </div>
</body>
</html>
```

#### 2.3 选择并上传文件

**操作步骤**：
1. 点击"选择文件"按钮
2. 在手机文件管理器中选择要上传的文件
3. 点击"开始上传"按钮
4. 等待上传完成

**上传逻辑**：
- 使用FormData对象封装文件数据
- 添加会话ID到请求头
- 监听上传进度
- 显示上传状态

**核心JavaScript**：
```javascript
const fileInput = document.getElementById('fileInput');
const uploadBtn = document.getElementById('uploadBtn');
const progressContainer = document.getElementById('progressContainer');
const fileList = document.getElementById('fileList');
const sessionId = new URLSearchParams(window.location.search).get('sessionId');

uploadBtn.addEventListener('click', () => {
    const files = fileInput.files;
    if (files.length === 0) {
        alert('请选择要上传的文件');
        return;
    }
    
    for (let i = 0; i < files.length; i++) {
        uploadFile(files[i]);
    }
});

function uploadFile(file) {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('sessionId', sessionId);
    
    const xhr = new XMLHttpRequest();
    
    // 创建进度条
    const progressDiv = document.createElement('div');
    const progressBar = document.createElement('div');
    const fileName = document.createElement('div');
    
    fileName.textContent = file.name;
    progressBar.className = 'progress-bar';
    progressDiv.appendChild(fileName);
    progressDiv.appendChild(progressBar);
    progressContainer.appendChild(progressDiv);
    
    // 监听上传进度
    xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable) {
            const percentComplete = (event.loaded / event.total) * 100;
            progressBar.style.width = percentComplete + '%';
            progressBar.textContent = percentComplete.toFixed(0) + '%';
        }
    });
    
    // 监听上传完成
    xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
            const result = JSON.parse(xhr.responseText);
            if (result.code === 200) {
                const successDiv = document.createElement('div');
                successDiv.className = 'success';
                successDiv.textContent = `${file.name} 上传成功`;
                fileList.appendChild(successDiv);
            } else {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = `${file.name} 上传失败：${result.message}`;
                fileList.appendChild(errorDiv);
            }
        } else {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = `${file.name} 上传失败：服务器错误`;
            fileList.appendChild(errorDiv);
        }
    });
    
    // 发送请求
    xhr.open('POST', '/api/v1/upload/mobile', true);
    xhr.setRequestHeader('X-Session-Id', sessionId);
    xhr.send(formData);
}
```

### 3. 后端流程

#### 3.1 上传会话管理

**数据结构**：
```java
public class UploadSession {
    private String sessionId;
    private String caseId;
    private LocalDateTime createTime;
    private LocalDateTime expireTime;
    private List<UploadedFile> files;
    private String status; // PENDING, PROCESSING, COMPLETED
    // getters and setters
}
```

**会话管理**：
- 生成唯一会话ID
- 设置5分钟过期时间
- 存储会话信息到Redis或数据库
- 提供会话状态查询接口

#### 3.2 文件上传API

**接口路径**：`POST /api/v1/upload/mobile`

**请求参数**：
- `file`：要上传的文件（multipart/form-data）
- `sessionId`：上传会话ID

**响应格式**：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "fileId": 123,
    "fileName": "example.jpg",
    "fileSize": 1024000,
    "fileUrl": "/files/example.jpg"
  }
}
```

**实现逻辑**：
1. 验证会话ID是否有效
2. 验证文件大小和类型
3. 保存文件到存储服务
4. 更新会话状态
5. 返回上传结果

#### 3.3 上传状态查询API

**接口路径**：`GET /api/v1/upload/status/{sessionId}`

**响应格式**：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "sessionId": "upload_1706234567890_abc123",
    "status": "COMPLETED",
    "files": [
      {
        "fileId": 123,
        "fileName": "example.jpg",
        "fileSize": 1024000,
        "fileUrl": "/files/example.jpg"
      }
    ]
  }
}
```

**实现逻辑**：
1. 查询会话信息
2. 检查会话是否过期
3. 返回会话状态和已上传文件列表

## 四、文件处理

### 1. 文件预览

**支持的图片格式**：
- .jpg, .jpeg, .png, .gif, .bmp, .webp, .svg

**预览原理**：
- 对于已上传的文件，生成预览URL
- 对于本地文件，使用URL.createObjectURL生成本地预览URL

**实现代码**：
```typescript
// 处理文件变化
const handleFileChange = (file: UploadFile, fileList: UploadFile[]) => {
  // 处理本地文件预览
  const updatedFileList = fileList.map(fileItem => {
    // 如果是本地文件且是图片类型，创建预览URL
    if (fileItem.raw && isImageFile(fileItem.name) && !fileItem.url) {
      return {
        ...fileItem,
        url: URL.createObjectURL(fileItem.raw) // 创建本地预览URL
      };
    }
    return fileItem;
  });
  
  uploadFiles.value = updatedFileList;
};
```

### 2. 文件删除

**删除逻辑**：
- 对于本地文件，直接从列表中删除
- 对于已上传的文件，调用API删除

**实现代码**：
```typescript
const handleFileRemove = (file: UploadFile) => {
  ElMessageBox.confirm('确定要删除这个文件吗？', '删除确认', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning',
  }).then(async () => {
    const fileId = file.id || file.response?.id;
    if (fileId) {
      // 调用删除API
      await requestClient8085.delete(`/file/${fileId}`);
      ElMessage.success('文件删除成功');
    }
    
    // 从列表中删除
    const index = uploadFiles.value.findIndex(item => item.uid === file.uid);
    if (index !== -1) {
      uploadFiles.value.splice(index, 1);
    }
  });
};
```

### 3. 文件排序

**实现方式**：
- 使用Sortable.js实现拖拽排序
- 支持长按拖拽（移动端）

**实现代码**：
```typescript
const initializeSortable = () => {
  if (!fileListContainer.value) return;
  
  Sortable.create(fileListContainer.value, {
    animation: 300,
    delay: 400,
    delayOnTouchOnly: true,
    handle: '.file-drag-handle',
    onEnd: (evt: any) => {
      const { oldIndex, newIndex } = evt;
      if (oldIndex !== undefined && newIndex !== undefined && oldIndex !== newIndex) {
        const movedItem = uploadFiles.value.splice(oldIndex, 1)[0];
        uploadFiles.value.splice(newIndex, 0, movedItem);
      }
    },
  });
};
```

## 五、常见问题及解决方案

### 1. 二维码扫描后无法打开网页

**可能原因**：
- 手机和电脑不在同一网络
- 服务器防火墙限制
- 二维码URL错误
- 手机浏览器不支持

**解决方案**：
- 确保手机和电脑连接到同一WiFi网络
- 检查服务器防火墙设置，允许外部访问
- 检查二维码URL是否正确
- 尝试使用Chrome或Safari浏览器

### 2. 上传速度慢

**可能原因**：
- 网络带宽限制
- 文件大小过大
- 服务器负载高

**解决方案**：
- 压缩文件后再上传
- 确保网络连接稳定
- 避免在高峰期上传大文件

### 3. 上传后文件不显示

**可能原因**：
- 上传会话过期
- 前端轮询失败
- 后端会话更新失败

**解决方案**：
- 重新生成二维码
- 检查浏览器控制台是否有错误
- 检查后端日志

### 4. 部分文件类型无法上传

**可能原因**：
- 后端文件类型限制
- 文件大小超过限制

**解决方案**：
- 检查后端配置的允许文件类型
- 检查文件大小是否超过限制

## 六、安全考虑

### 1. 会话安全
- 会话ID使用随机字符串生成
- 会话设置过期时间
- 限制单个会话的文件数量和大小

### 2. 文件安全
- 验证文件类型和大小
- 扫描文件是否包含恶意代码
- 存储文件时重命名，避免路径遍历攻击

### 3. 传输安全
- 使用HTTPS协议
- 验证请求来源
- 限制请求频率

## 七、优化建议

### 1. 实时通知
- 使用WebSocket替代轮询，减少服务器负载
- 上传完成后立即通知前端

### 2. 断点续传
- 支持大文件断点续传
- 提高上传成功率

### 3. 多文件并行上传
- 支持同时上传多个文件
- 提高上传效率

### 4. 文件压缩
- 自动压缩图片文件
- 减少上传时间和存储空间

## 八、部署说明

### 1. 前端部署
- 确保qrcode.vue依赖已安装
- 配置正确的API_BASE_URL
- 构建生产版本

### 2. 后端部署
- 配置文件存储路径
- 配置Redis或数据库连接
- 配置文件上传限制
- 配置CORS允许跨域访问

### 3. 网络配置
- 确保服务器可以被外部访问
- 配置正确的域名和端口
- 配置SSL证书，使用HTTPS

## 九、测试方法

### 1. 功能测试
- 测试二维码生成是否正确
- 测试手机扫描是否能打开上传页面
- 测试文件上传是否成功
- 测试上传后文件是否显示在列表中

### 2. 性能测试
- 测试大文件上传速度
- 测试多文件并行上传
- 测试不同网络环境下的上传性能

### 3. 兼容性测试
- 测试不同手机浏览器
- 测试不同操作系统
- 测试不同网络环境

## 十、总结

手机扫码上传文件功能为用户提供了一种便捷的文件上传方式，特别适合需要从手机中快速上传文件的场景。该功能的实现涉及前端、后端和移动端的协同工作，需要考虑安全性、性能和用户体验等多个方面。

通过合理的设计和优化，可以提高上传成功率和用户体验，为用户提供更好的服务。
