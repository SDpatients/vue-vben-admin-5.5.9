# 登录与权限完整方案

## 一、方案概述

本文档描述了基于双令牌机制（Access Token + Refresh Token）、登录安全增强和统一权限中心的完整登录与权限控制方案，支持用户名密码登录和手机验证码登录两种方式。

### 1.3 特殊API说明

- **案件流程相关API**：案件流程相关API（使用8085端口）不需要进行权限校验，系统会自动放行Token校验，直接允许访问。

#### 1.3.1 案件流程相关API范围

案件流程相关API包括但不限于以下类型：
- 案件基本信息查询与管理
- 债权人信息管理
- 债务人信息管理
- 银行账户信息管理
- 操作跟踪记录
- 工作计划管理
- 工作团队管理

#### 1.3.2 前端配置与使用

前端项目中已配置专门的API客户端用于访问案件流程相关API：

```typescript
// 8085端口API客户端（不进行Token校验）
export const requestClient8085 = new RequestClient({
  baseURL: 'http://192.168.0.120:8085',
  responseReturn: 'body',
});
```

所有案件流程相关API调用均应使用此客户端，该客户端不会添加Token请求头，也不会处理Token过期逻辑。

#### 1.3.3 后端处理机制

后端服务在8085端口部署，针对案件流程相关API：
- 不进行JWT Token验证
- 不检查用户角色权限
- 不记录详细的权限审计日志
- 仅进行基本的请求合法性验证

#### 1.3.4 适用场景

案件流程相关API适用于：
- 案件信息的公开查询
- 案件流程的基本操作
- 与外部系统的集成对接
- 无需严格权限控制的业务场景

### 1.1 技术栈

- **后端框架**：Spring Boot 2.6.13 + MyBatis
- **数据库**：SQL Server 2008 R2
- **缓存**：Redis
- **JWT库**：jjwt 0.11.5
- **短信服务**：阿里云短信（可扩展其他服务商）
- **前端**：Vue/React/原生JS（通用）

### 1.2 核心特性

- **双令牌机制**：Access Token（15分钟） + Refresh Token（7天）
- **多种登录方式**：用户名密码登录 + 手机验证码登录
- **安全增强**：登录失败限制、验证码、设备绑定、异地登录检测
- **统一权限中心**：角色权限管理、菜单权限控制
- **SSO扩展支持**：统一认证接口预留

---

## 二、数据库设计（SQL Server 2008）

### 2.1 核心表结构

```sql
-- ============================================
-- 1. 用户表（扩展原有User表）
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_USER]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_USER] (
        [u_pid] INT IDENTITY(1,1) PRIMARY KEY,           -- 用户ID（主键）
        [u_user] NVARCHAR(50) NOT NULL,                  -- 用户名（登录账号）
        [u_pwd] NVARCHAR(100) NOT NULL,                  -- 密码（MD5加密）
        [u_name] NVARCHAR(50) NOT NULL,                  -- 真实姓名
        [u_mobile] NVARCHAR(20),                         -- 手机号（用于短信登录）
        [u_email] NVARCHAR(100),                         -- 邮箱
        [u_tel] NVARCHAR(20),                            -- 联系电话
        [u_deptid] INT,                                  -- 部门ID
        [u_dept] NVARCHAR(100),                          -- 部门名称
        [u_valid] CHAR(1) DEFAULT '1',                   -- 是否有效（1-有效 0-无效）
        [u_status] CHAR(1) DEFAULT '1',                  -- 用户状态（1-正常 2-锁定 3-禁用）
        [u_login_type] CHAR(1) DEFAULT '1',              -- 登录方式（1-用户名 2-手机号）
        [u_bind_device] NVARCHAR(500),                   -- 绑定设备ID（加密存储）
        [u_last_login_time] DATETIME,                    -- 最后登录时间
        [u_last_login_ip] NVARCHAR(50),                  -- 最后登录IP
        [u_login_count] INT DEFAULT 0,                   -- 登录次数
        [u_pwd_error_count] INT DEFAULT 0,               -- 密码错误次数
        [u_pwd_error_time] DATETIME,                     -- 最后密码错误时间
        [u_pwd_expire_time] DATETIME,                    -- 密码过期时间
        [sep_auser] NVARCHAR(50),                        -- 创建人
        [sep_adate] DATETIME DEFAULT GETDATE(),          -- 创建时间
        [sep_euser] NVARCHAR(50),                        -- 修改人
        [sep_edate] DATETIME,                            -- 修改时间
        CONSTRAINT UQ_USER_USER UNIQUE ([u_user]),
        CONSTRAINT UQ_USER_MOBILE UNIQUE ([u_mobile])
    );
END
GO

-- 创建索引
CREATE INDEX IDX_USER_MOBILE ON TB_USER([u_mobile]);
CREATE INDEX IDX_USER_STATUS ON TB_USER([u_status]);
CREATE INDEX IDX_USER_DEPT ON TB_USER([u_deptid]);
GO

-- ============================================
-- 2. 角色表
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_ROLE]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_ROLE] (
        [role_id] INT IDENTITY(1,1) PRIMARY KEY,         -- 角色ID
        [role_code] NVARCHAR(50) NOT NULL,               -- 角色编码
        [role_name] NVARCHAR(100) NOT NULL,              -- 角色名称
        [role_desc] NVARCHAR(500),                       -- 角色描述
        [is_system] CHAR(1) DEFAULT '0',                 -- 是否系统角色（0-否 1-是）
        [status] CHAR(1) DEFAULT '1',                    -- 状态（1-启用 0-禁用）
        [sort_order] INT DEFAULT 0,                      -- 排序
        [sep_auser] NVARCHAR(50),                        -- 创建人
        [sep_adate] DATETIME DEFAULT GETDATE(),          -- 创建时间
        [sep_euser] NVARCHAR(50),                        -- 修改人
        [sep_edate] DATETIME,                            -- 修改时间
        CONSTRAINT UQ_ROLE_CODE UNIQUE ([role_code])
    );
END
GO

-- 初始化系统角色
IF NOT EXISTS (SELECT * FROM TB_ROLE)
BEGIN
    INSERT INTO TB_ROLE (role_code, role_name, role_desc, is_system, sort_order) VALUES
    ('SUPER_ADMIN', '超级管理员', '系统超级管理员，拥有所有权限', '1', 1),
    ('ADMIN', '管理员', '系统管理员，拥有大部分权限', '1', 2),
    ('LAWYER', '律师', '普通律师用户', '0', 3),
    ('CLERK', '书记员', '书记员用户', '0', 4),
    ('VIEWER', '只读用户', '只读访问用户', '0', 5);
END
GO

-- ============================================
-- 3. 用户角色关联表
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_USER_ROLE]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_USER_ROLE] (
        [id] INT IDENTITY(1,1) PRIMARY KEY,
        [u_pid] INT NOT NULL,                            -- 用户ID
        [role_id] INT NOT NULL,                          -- 角色ID
        [sep_auser] NVARCHAR(50),                        -- 创建人
        [sep_adate] DATETIME DEFAULT GETDATE(),          -- 创建时间
        CONSTRAINT UQ_USER_ROLE UNIQUE ([u_pid], [role_id])
    );
END
GO

-- ============================================
-- 4. 权限（菜单）表
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_PERMISSION]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_PERMISSION] (
        [perm_id] INT IDENTITY(1,1) PRIMARY KEY,         -- 权限ID
        [perm_code] NVARCHAR(100) NOT NULL,              -- 权限编码（如：case:view, case:add）
        [perm_name] NVARCHAR(100) NOT NULL,              -- 权限名称
        [perm_type] CHAR(1) NOT NULL,                    -- 权限类型（1-菜单 2-按钮 3-接口）
        [parent_id] INT DEFAULT 0,                       -- 父级ID
        [path] NVARCHAR(200),                            -- 路由路径
        [component] NVARCHAR(200),                       -- 前端组件路径
        [icon] NVARCHAR(100),                            -- 图标
        [sort_order] INT DEFAULT 0,                      -- 排序
        [status] CHAR(1) DEFAULT '1',                    -- 状态（1-启用 0-禁用）
        [is_external] CHAR(1) DEFAULT '0',               -- 是否外部链接
        [sep_auser] NVARCHAR(50),                        -- 创建人
        [sep_adate] DATETIME DEFAULT GETDATE(),          -- 创建时间
        [sep_euser] NVARCHAR(50),                        -- 修改人
        [sep_edate] DATETIME,                            -- 修改时间
        CONSTRAINT UQ_PERM_CODE UNIQUE ([perm_code])
    );
END
GO

-- ============================================
-- 5. 角色权限关联表
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_ROLE_PERMISSION]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_ROLE_PERMISSION] (
        [id] INT IDENTITY(1,1) PRIMARY KEY,
        [role_id] INT NOT NULL,                          -- 角色ID
        [perm_id] INT NOT NULL,                          -- 权限ID
        [sep_auser] NVARCHAR(50),                        -- 创建人
        [sep_adate] DATETIME DEFAULT GETDATE(),          -- 创建时间
        CONSTRAINT UQ_ROLE_PERM UNIQUE ([role_id], [perm_id])
    );
END
GO

-- ============================================
-- 6. 令牌表（用于Refresh Token管理和令牌黑名单）
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_TOKEN]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_TOKEN] (
        [token_id] INT IDENTITY(1,1) PRIMARY KEY,
        [u_pid] INT NOT NULL,                            -- 用户ID
        [token_type] CHAR(1) NOT NULL,                  -- 令牌类型（1-Access 2-Refresh）
        [token_value] NVARCHAR(500) NOT NULL,           -- 令牌值（加密存储）
        [device_id] NVARCHAR(200),                       -- 设备ID
        [device_info] NVARCHAR(500),                     -- 设备信息
        [ip_address] NVARCHAR(50),                       -- IP地址
        [expire_time] DATETIME NOT NULL,                 -- 过期时间
        [create_time] DATETIME DEFAULT GETDATE(),        -- 创建时间
        [revoke_time] DATETIME,                          -- 撤销时间
        [status] CHAR(1) DEFAULT '1',                    -- 状态（1-有效 0-已失效）
        CONSTRAINT UQ_TOKEN_VALUE UNIQUE ([token_value])
    );
END
GO

-- 创建过期索引
CREATE INDEX IDX_TOKEN_EXPIRE ON TB_TOKEN([expire_time], [status]);
CREATE INDEX IDX_TOKEN_USER ON TB_TOKEN([u_pid], [token_type]);
GO

-- ============================================
-- 7. 短信验证码表
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_SMS_CODE]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_SMS_CODE] (
        [sms_id] INT IDENTITY(1,1) PRIMARY KEY,
        [mobile] NVARCHAR(20) NOT NULL,                  -- 手机号
        [code] NVARCHAR(10) NOT NULL,                    -- 验证码
        [sms_type] CHAR(1) NOT NULL,                     -- 验证码类型（1-登录 2-注册 3-找回密码 4-绑定手机）
        [expire_time] DATETIME NOT NULL,                 -- 过期时间
        [used_time] DATETIME,                            -- 使用时间
        [used_status] CHAR(1) DEFAULT '0',               -- 使用状态（0-未使用 1-已使用）
        [create_time] DATETIME DEFAULT GETDATE(),        -- 创建时间
        CONSTRAINT IDX_SMS_MOBILE_TYPE UNIQUE ([mobile], [sms_type])
    );
END
GO

-- ============================================
-- 8. 登录日志表（扩展原有LoginRecord）
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_LOGIN_RECORD]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_LOGIN_RECORD] (
        [login_id] INT IDENTITY(1,1) PRIMARY KEY,
        [u_pid] INT,                                     -- 用户ID
        [u_user] NVARCHAR(50),                           -- 用户名
        [u_name] NVARCHAR(50),                           -- 真实姓名
        [login_type] CHAR(1),                            -- 登录方式（1-用户名密码 2-手机验证码）
        [login_ip] NVARCHAR(50),                         -- 登录IP
        [login_location] NVARCHAR(200),                  -- IP归属地
        [login_device] NVARCHAR(500),                    -- 登录设备信息
        [login_browser] NVARCHAR(200),                   -- 浏览器信息
        [login_os] NVARCHAR(100),                        -- 操作系统
        [login_status] CHAR(1) NOT NULL,                 -- 登录状态（1-成功 0-失败）
        [error_msg] NVARCHAR(500),                       -- 错误信息
        [risk_level] CHAR(1) DEFAULT '1',                -- 风险等级（1-低 2-中 3-高）
        [is_known_device] CHAR(1) DEFAULT '0',           -- 是否已知设备
        [create_time] DATETIME DEFAULT GETDATE()         -- 登录时间
    );
END
GO

CREATE INDEX IDX_LOGIN_USER ON TB_LOGIN_RECORD([u_pid], [create_time]);
CREATE INDEX IDX_LOGIN_IP ON TB_LOGIN_RECORD([login_ip], [create_time]);
GO

-- ============================================
-- 9. 设备绑定表
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_DEVICE_BINDING]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_DEVICE_BINDING] (
        [binding_id] INT IDENTITY(1,1) PRIMARY KEY,
        [u_pid] INT NOT NULL,                            -- 用户ID
        [device_id] NVARCHAR(200) NOT NULL,              -- 设备唯一标识
        [device_name] NVARCHAR(100),                     -- 设备名称（如：我的电脑）
        [device_info] NVARCHAR(500),                     -- 设备详细信息
        [ip_address] NVARCHAR(50),                       -- 绑定IP
        [last_login_time] DATETIME,                      -- 最后使用时间
        [login_count] INT DEFAULT 0,                     -- 登录次数
        [is_trusted] CHAR(1) DEFAULT '1',                -- 是否可信设备
        [status] CHAR(1) DEFAULT '1',                    -- 状态（1-正常 0-已解绑）
        [create_time] DATETIME DEFAULT GETDATE(),        -- 绑定时间
        [sep_euser] NVARCHAR(50),                        -- 操作人
        [sep_edate] DATETIME,                            -- 操作时间
        CONSTRAINT UQ_USER_DEVICE UNIQUE ([u_pid], [device_id])
    );
END
GO

-- ============================================
-- 10. 登录失败记录表（用于防暴力破解）
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_LOGIN_FAIL]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_LOGIN_FAIL] (
        [fail_id] INT IDENTITY(1,1) PRIMARY KEY,
        [login_account] NVARCHAR(100) NOT NULL,          -- 登录账号（用户名或手机号）
        [fail_ip] NVARCHAR(50) NOT NULL,                 -- 失败IP
        [fail_count] INT DEFAULT 1,                      -- 失败次数
        [fail_type] CHAR(1) NOT NULL,                    -- 失败类型（1-用户名密码 2-手机验证码）
        [last_fail_time] DATETIME DEFAULT GETDATE(),     -- 最后失败时间
        [unlock_time] DATETIME,                          -- 解锁时间
        [status] CHAR(1) DEFAULT '1'                     -- 状态（1-锁定中 0-已解锁）
    );
END
GO

CREATE INDEX IDX_FAIL_ACCOUNT ON TB_LOGIN_FAIL([login_account], [status]);
CREATE INDEX IDX_FAIL_IP ON TB_LOGIN_FAIL([fail_ip], [status]);
GO

-- ============================================
-- 11. 系统配置表
-- ============================================
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_SYSTEM_CONFIG]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[TB_SYSTEM_CONFIG] (
        [config_id] INT IDENTITY(1,1) PRIMARY KEY,
        [config_key] NVARCHAR(100) NOT NULL,             -- 配置键
        [config_value] NVARCHAR(500),                    -- 配置值
        [config_desc] NVARCHAR(500),                     -- 配置描述
        [config_group] NVARCHAR(100),                    -- 配置分组
        [sort_order] INT DEFAULT 0,                      -- 排序
        [status] CHAR(1) DEFAULT '1',                    -- 状态
        [sep_auser] NVARCHAR(50),                        -- 创建人
        [sep_adate] DATETIME DEFAULT GETDATE(),          -- 创建时间
        CONSTRAINT UQ_CONFIG_KEY UNIQUE ([config_key])
    );
END
GO

-- 初始化安全配置
IF NOT EXISTS (SELECT * FROM TB_SYSTEM_CONFIG WHERE config_key = 'LOGIN_MAX_FAIL_COUNT')
BEGIN
    INSERT INTO TB_SYSTEM_CONFIG (config_key, config_value, config_desc, config_group) VALUES
    ('LOGIN_MAX_FAIL_COUNT', '5', '登录最大失败次数', 'SECURITY'),
    ('LOGIN_FAIL_LOCK_TIME', '15', '登录失败锁定时间（分钟）', 'SECURITY'),
    ('SMS_CODE_EXPIRE', '5', '短信验证码有效期（分钟）', 'SECURITY'),
    ('ACCESS_TOKEN_EXPIRE', '15', 'Access Token有效期（分钟）', 'TOKEN'),
    ('REFRESH_TOKEN_EXPIRE', '10080', 'Refresh Token有效期（分钟）', 'TOKEN'),
    ('PASSWORD_EXPIRE_DAYS', '90', '密码过期天数', 'SECURITY'),
    ('ENABLE_DEVICE_BINDING', '0', '是否启用设备绑定（0-否 1-是）', 'SECURITY'),
    ('ENABLE_LOGIN_VERIFY', '0', '是否启用登录验证码（0-否 1-是）', 'SECURITY'),
    ('ALLOW_MULTI_LOGIN', '1', '是否允许重复登录（0-否 1-是）', 'SECURITY'),
    ('LOGIN_RISK_CHECK', '1', '是否启用登录风险检测', 'SECURITY');
END
GO
```

### 2.2 数据同步SQL（将原有数据迁移到新表）

```sql
-- ============================================
-- 数据迁移：将原有用户表数据同步到新表
-- ============================================

-- 如果原有用户表存在且有新字段
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TB_USER_OLD]') AND type in (N'U'))
BEGIN
    -- 复制原有数据到新表（根据实际情况调整字段映射）
    INSERT INTO TB_USER (u_user, u_pwd, u_name, u_deptid, u_dept, u_tel, u_mobile, u_email, u_valid, sep_auser, sep_adate)
    SELECT u_user, u_pwd, u_name, u_deptid, u_dept, u_tel, u_mobile, u_email, u_valid, sep_auser, sep_adate
    FROM TB_USER_OLD;
END
GO
```

---

## 三、后端实现

### 3.1 Maven依赖（pom.xml新增）

```xml
<!-- 短信服务依赖 -->
<dependency>
    <groupId>com.aliyun</groupId>
    <artifactId>aliyun-java-sdk-core</artifactId>
    <version>4.5.16</version>
</dependency>
<dependency>
    <groupId>com.aliyun</groupId>
    <artifactId>aliyun-java-sdk-dysmsapi</artifactId>
    <version>2.1.0</version>
</dependency>

<!-- Redis缓存 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!-- 缓存连接池 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>

<!-- 加密工具 -->
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
    <version>1.15</version>
</dependency>

<!-- Guava限流 -->
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>31.1-jre</version>
</dependency>
```

### 3.2 配置文件（application.properties新增）

```properties
# Redis配置
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
spring.redis.database=0
spring.redis.timeout=60000
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-wait=-1
spring.redis.lettuce.pool.max-idle=8
spring.redis.lettuce.pool.min-idle=2

# 阿里云短信配置
aliyun.sms.access-key-id=your-access-key-id
aliyun.sms.access-key-secret=your-access-key-secret
aliyun.sms.sign-name=法律案件管理系统
aliyun.sms.template-code.login=SMS_123456789
aliyun.sms.template-code.register=SMS_987654321
aliyun.sms.template-code.reset-pwd=SMS_111222333

# 文件上传配置
file.upload.path=C:/law-upload
file.allowed.types=doc,docx,jpg,pdf,png,xls,xlsx,txt
file.max.size=10485760
spring.servlet.multipart.max-file-size=100MB
spring.servlet.multipart.max-request-size=100MB
spring.servlet.multipart.enabled=true
spring.servlet.multipart.file-size-threshold=2KB
```

### 3.3 核心实体类

#### 3.3.1 User实体（扩展）

```java
package com.ls.law.entity;

import java.util.Date;

public class User {
    private Integer uPid;
    private String uUser;
    private String uPwd;
    private String uName;
    private String uMobile;
    private String uEmail;
    private String uTel;
    private Integer uDeptid;
    private String uDept;
    private String uValid;
    private String uStatus;
    private String uLoginType;
    private String uBindDevice;
    private Date uLastLoginTime;
    private String uLastLoginIp;
    private Integer uLoginCount;
    private Integer uPwdErrorCount;
    private Date uPwdErrorTime;
    private Date uPwdExpireTime;
    private String sepAuser;
    private Date sepAdate;
    private String sepEuser;
    private Date sepEdate;
    
    // 角色列表（不存入数据库）
    private java.util.List<Role> roles;
    
    // 权限列表（不存入数据库）
    private java.util.List<Permission> permissions;
    
    // Getters and Setters
    public Integer getuPid() { return uPid; }
    public void setuPid(Integer uPid) { this.uPid = uPid; }
    public String getuUser() { return uUser; }
    public void setuUser(String uUser) { this.uUser = uUser; }
    public String getuPwd() { return uPwd; }
    public void setuPwd(String uPwd) { this.uPwd = uPwd; }
    public String getuName() { return uName; }
    public void setuName(String uName) { this.uName = uName; }
    public String getuMobile() { return uMobile; }
    public void setuMobile(String uMobile) { this.uMobile = uMobile; }
    public String getuEmail() { return uEmail; }
    public void setuEmail(String uEmail) { this.uEmail = uEmail; }
    public String getuTel() { return uTel; }
    public void setuTel(String uTel) { this.uTel = uTel; }
    public Integer getuDeptid() { return uDeptid; }
    public void setuDeptid(Integer uDeptid) { this.uDeptid = uDeptid; }
    public String getuDept() { return uDept; }
    public void setuDept(String uDept) { this.uDept = uDept; }
    public String getuValid() { return uValid; }
    public void setuValid(String uValid) { this.uValid = uValid; }
    public String getuStatus() { return uStatus; }
    public void setuStatus(String uStatus) { this.uStatus = uStatus; }
    public String getuLoginType() { return uLoginType; }
    public void setuLoginType(String uLoginType) { this.uLoginType = uLoginType; }
    public String getuBindDevice() { return uBindDevice; }
    public void setuBindDevice(String uBindDevice) { this.uBindDevice = uBindDevice; }
    public Date getuLastLoginTime() { return uLastLoginTime; }
    public void setuLastLoginTime(Date uLastLoginTime) { this.uLastLoginTime = uLastLoginTime; }
    public String getuLastLoginIp() { return uLastLoginIp; }
    public void setuLastLoginIp(String uLastLoginIp) { this.uLastLoginIp = uLastLoginIp; }
    public Integer getuLoginCount() { return uLoginCount; }
    public void setuLoginCount(Integer uLoginCount) { this.uLoginCount = uLoginCount; }
    public Integer getuPwdErrorCount() { return uPwdErrorCount; }
    public void setuPwdErrorCount(Integer uPwdErrorCount) { this.uPwdErrorCount = uPwdErrorCount; }
    public Date getuPwdErrorTime() { return uPwdErrorTime; }
    public void setuPwdErrorTime(Date uPwdErrorTime) { this.uPwdErrorTime = uPwdErrorTime; }
    public Date getuPwdExpireTime() { return uPwdExpireTime; }
    public void setuPwdExpireTime(Date uPwdExpireTime) { this.uPwdExpireTime = uPwdExpireTime; }
    public java.util.List<Role> getRoles() { return roles; }
    public void setRoles(java.util.List<Role> roles) { this.roles = roles; }
    public java.util.List<Permission> getPermissions() { return permissions; }
    public void setPermissions(java.util.List<Permission> permissions) { this.permissions = permissions; }
}
```

#### 3.3.2 Role实体

```java
package com.ls.law.entity;

import java.util.Date;

public class Role {
    private Integer roleId;
    private String roleCode;
    private String roleName;
    private String roleDesc;
    private String isSystem;
    private String status;
    private Integer sortOrder;
    private String sepAuser;
    private Date sepAdate;
    private String sepEuser;
    private Date sepEdate;
    
    // Getters and Setters
    public Integer getRoleId() { return roleId; }
    public void setRoleId(Integer roleId) { this.roleId = roleId; }
    public String getRoleCode() { return roleCode; }
    public void setRoleCode(String roleCode) { this.roleCode = roleCode; }
    public String getRoleName() { return roleName; }
    public void setRoleName(String roleName) { this.roleName = roleName; }
    public String getRoleDesc() { return roleDesc; }
    public void setRoleDesc(String roleDesc) { this.roleDesc = roleDesc; }
    public String getIsSystem() { return isSystem; }
    public void setIsSystem(String isSystem) { this.isSystem = isSystem; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    public Integer getSortOrder() { return sortOrder; }
    public void setSortOrder(Integer sortOrder) { this.sortOrder = sortOrder; }
}
```

#### 3.3.3 Permission实体

```java
package com.ls.law.entity;

import java.util.Date;

public class Permission {
    private Integer permId;
    private String permCode;
    private String permName;
    private String permType;
    private Integer parentId;
    private String path;
    private String component;
    private String icon;
    private Integer sortOrder;
    private String status;
    private String isExternal;
    private String sepAuser;
    private Date sepAdate;
    private String sepEuser;
    private Date sepEdate;
    
    // 子权限列表
    private java.util.List<Permission> children;
    
    // Getters and Setters
    public Integer getPermId() { return permId; }
    public void setPermId(Integer permId) { this.permId = permId; }
    public String getPermCode() { return permCode; }
    public void setPermCode(String permCode) { this.permCode = permCode; }
    public String getPermName() { return permName; }
    public void setPermName(String permName) { this.permName = permName; }
    public String getPermType() { return permType; }
    public void setPermType(String permType) { this.permType = permType; }
    public Integer getParentId() { return parentId; }
    public void setParentId(Integer parentId) { this.parentId = parentId; }
    public String getPath() { return path; }
    public void setPath(String path) { this.path = path; }
    public String getComponent() { return component; }
    public void setComponent(String component) { this.component = component; }
    public java.util.List<Permission> getChildren() { return children; }
    public void setChildren(java.util.List<Permission> children) { this.children = children; }
}
```

#### 3.3.4 Token实体

```java
package com.ls.law.entity;

import java.util.Date;

public class Token {
    private Integer tokenId;
    private Integer uPid;
    private String tokenType;
    private String tokenValue;
    private String deviceId;
    private String deviceInfo;
    private String ipAddress;
    private Date expireTime;
    private Date createTime;
    private Date revokeTime;
    private String status;
    
    // Getters and Setters
    public Integer getTokenId() { return tokenId; }
    public void setTokenId(Integer tokenId) { this.tokenId = tokenId; }
    public Integer getuPid() { return uPid; }
    public void setuPid(Integer uPid) { this.uPid = uPid; }
    public String getTokenType() { return tokenType; }
    public void setTokenType(String tokenType) { this.tokenType = tokenType; }
    public String getTokenValue() { return tokenValue; }
    public void setTokenValue(String tokenValue) { this.tokenValue = tokenValue; }
    public String getDeviceId() { return deviceId; }
    public void setDeviceId(String deviceId) { this.deviceId = deviceId; }
    public String getIpAddress() { return ipAddress; }
    public void setIpAddress(String ipAddress) { this.ipAddress = ipAddress; }
    public Date getExpireTime() { return expireTime; }
    public void setExpireTime(Date expireTime) { this.expireTime = expireTime; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
}
```

#### 3.3.5 SmsCode实体

```java
package com.ls.law.entity;

import java.util.Date;

public class SmsCode {
    private Integer smsId;
    private String mobile;
    private String code;
    private String smsType;
    private Date expireTime;
    private Date usedTime;
    private String usedStatus;
    private Date createTime;
    
    // Getters and Setters
    public Integer getSmsId() { return smsId; }
    public void setSmsId(Integer smsId) { this.smsId = smsId; }
    public String getMobile() { return mobile; }
    public void setMobile(String mobile) { this.mobile = mobile; }
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    public String getSmsType() { return smsType; }
    public void setSmsType(String smsType) { this.smsType = smsType; }
    public Date getExpireTime() { return expireTime; }
    public void setExpireTime(Date expireTime) { this.expireTime = expireTime; }
    public String getUsedStatus() { return usedStatus; }
    public void setUsedStatus(String usedStatus) { this.usedStatus = usedStatus; }
}
```

#### 3.3.6 LoginRecord实体

```java
package com.ls.law.entity;

import java.util.Date;

public class LoginRecord {
    private Integer loginId;
    private Integer uPid;
    private String uUser;
    private String uName;
    private String loginType;
    private String loginIp;
    private String loginLocation;
    private String loginDevice;
    private String loginBrowser;
    private String loginOs;
    private String loginStatus;
    private String errorMsg;
    private String riskLevel;
    private String isKnownDevice;
    private Date createTime;
    
    // Getters and Setters
    public Integer getLoginId() { return loginId; }
    public void setLoginId(Integer loginId) { this.loginId = loginId; }
    public Integer getuPid() { return uPid; }
    public void setuPid(Integer uPid) { this.uPid = uPid; }
    public String getuUser() { return uUser; }
    public void setuUser(String uUser) { this.uUser = uUser; }
    public String getuName() { return uName; }
    public void setuName(String uName) { this.uName = uName; }
    public String getLoginType() { return loginType; }
    public void setLoginType(String loginType) { this.loginType = loginType; }
    public String getLoginIp() { return loginIp; }
    public void setLoginIp(String loginIp) { this.loginIp = loginIp; }
    public String getLoginLocation() { return loginLocation; }
    public void setLoginLocation(String loginLocation) { this.loginLocation = loginLocation; }
    public String getLoginStatus() { return loginStatus; }
    public void setLoginStatus(String loginStatus) { this.loginStatus = loginStatus; }
    public String getRiskLevel() { return riskLevel; }
    public void setRiskLevel(String riskLevel) { this.riskLevel = riskLevel; }
    public Date getCreateTime() { return createTime; }
    public void setCreateTime(Date createTime) { this.createTime = createTime; }
}
```

#### 3.3.7 DeviceBinding实体

```java
package com.ls.law.entity;

import java.util.Date;

public class DeviceBinding {
    private Integer bindingId;
    private Integer uPid;
    private String deviceId;
    private String deviceName;
    private String deviceInfo;
    private String ipAddress;
    private Date lastLoginTime;
    private Integer loginCount;
    private String isTrusted;
    private String status;
    private Date createTime;
    private String sepEuser;
    private Date sepEdate;
    
    // Getters and Setters
    public Integer getBindingId() { return bindingId; }
    public void setBindingId(Integer bindingId) { this.bindingId = bindingId; }
    public Integer getuPid() { return uPid; }
    public void setuPid(Integer uPid) { this.uPid = uPid; }
    public String getDeviceId() { return deviceId; }
    public void setDeviceId(String deviceId) { this.deviceId = deviceId; }
    public String getDeviceName() { return deviceName; }
    public void setDeviceName(String deviceName) { this.deviceName = deviceName; }
    public String getIsTrusted() { return isTrusted; }
    public void setIsTrusted(String isTrusted) { this.isTrusted = isTrusted; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    public Date getCreateTime() { return createTime; }
    public void setCreateTime(Date createTime) { this.createTime = createTime; }
}
```

### 3.4 工具类

#### 3.4.1 JwtTokenService（双令牌服务）

```java
package com.ls.law.service.impl;

import com.ls.law.entity.Token;
import com.ls.law.mapper.TokenMapper;
import com.ls.law.utils.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.UUID;

@Service
public class JwtTokenService {
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Autowired
    private TokenMapper tokenMapper;
    
    @Value("${jwt.access-token-expire:900000}")  // 15分钟
    private long accessTokenExpire;
    
    @Value("${jwt.refresh-token-expire:604800000}")  // 7天
    private long refreshTokenExpire;
    
    private static final String TOKEN_TYPE_ACCESS = "1";
    private static final String TOKEN_TYPE_REFRESH = "2";
    private static final String STATUS_VALID = "1";
    private static final String STATUS_INVALID = "0";
    
    /**
     * 生成并保存双令牌
     */
    @Transactional
    public java.util.Map<String, Object> generateTokens(Integer userId, String deviceId, 
            String deviceInfo, String ipAddress) {
        java.util.Map<String, Object> result = new java.util.HashMap<>();
        
        // 生成Access Token
        String accessToken = jwtUtils.generateToken(userId);
        Date accessExpireTime = new Date(System.currentTimeMillis() + accessTokenExpire);
        
        // 保存Access Token到数据库
        Token accessTokenEntity = new Token();
        accessTokenEntity.setuPid(userId);
        accessTokenEntity.setTokenType(TOKEN_TYPE_ACCESS);
        accessTokenEntity.setTokenValue(jwtUtils.encryptToken(accessToken));
        accessTokenEntity.setDeviceId(deviceId);
        accessTokenEntity.setDeviceInfo(deviceInfo);
        accessTokenEntity.setIpAddress(ipAddress);
        accessTokenEntity.setExpireTime(accessExpireTime);
        accessTokenEntity.setStatus(STATUS_VALID);
        tokenMapper.insert(accessTokenEntity);
        
        // 生成Refresh Token
        String refreshToken = UUID.randomUUID().toString().replace("-", "");
        Date refreshExpireTime = new Date(System.currentTimeMillis() + refreshTokenExpire);
        
        // 保存Refresh Token到数据库
        Token refreshTokenEntity = new Token();
        refreshTokenEntity.setuPid(userId);
        refreshTokenEntity.setTokenType(TOKEN_TYPE_REFRESH);
        refreshTokenEntity.setTokenValue(jwtUtils.encryptToken(refreshToken));
        refreshTokenEntity.setDeviceId(deviceId);
        refreshTokenEntity.setDeviceInfo(deviceInfo);
        refreshTokenEntity.setIpAddress(ipAddress);
        refreshTokenEntity.setExpireTime(refreshExpireTime);
        refreshTokenEntity.setStatus(STATUS_VALID);
        tokenMapper.insert(refreshTokenEntity);
        
        result.put("accessToken", accessToken);
        result.put("accessTokenExpire", accessTokenExpire);
        result.put("refreshToken", refreshToken);
        result.put("refreshTokenExpire", refreshTokenExpire);
        
        return result;
    }
    
    /**
     * 使用Refresh Token换取新的Access Token
     */
    @Transactional
    public java.util.Map<String, Object> refreshAccessToken(String refreshToken, String deviceId,
            String deviceInfo, String ipAddress) {
        java.util.Map<String, Object> result = new java.util.HashMap<>();
        
        // 验证Refresh Token
        String encryptedToken = jwtUtils.encryptToken(refreshToken);
        Token storedToken = tokenMapper.findByTokenValueAndType(encryptedToken, TOKEN_TYPE_REFRESH);
        
        if (storedToken == null) {
            throw new RuntimeException("无效的Refresh Token");
        }
        
        if (STATUS_INVALID.equals(storedToken.getStatus())) {
            throw new RuntimeException("Refresh Token已失效");
        }
        
        if (storedToken.getExpireTime().before(new Date())) {
            throw new RuntimeException("Refresh Token已过期");
        }
        
        // 验证设备ID
        if (deviceId != null && !deviceId.equals(storedToken.getDeviceId())) {
            throw new RuntimeException("设备不一致，请使用原设备登录");
        }
        
        // 撤销旧的Refresh Token
        storedToken.setStatus(STATUS_INVALID);
        storedToken.setRevokeTime(new Date());
        tokenMapper.update(storedToken);
        
        // 生成新的令牌对
        return generateTokens(storedToken.getuPid(), deviceId, deviceInfo, ipAddress);
    }
    
    /**
     * 验证Access Token
     */
    public boolean validateAccessToken(String accessToken) {
        if (!jwtUtils.validateToken(accessToken)) {
            return false;
        }
        
        String encryptedToken = jwtUtils.encryptToken(accessToken);
        Token storedToken = tokenMapper.findByTokenValueAndType(encryptedToken, TOKEN_TYPE_ACCESS);
        
        if (storedToken == null) {
            return false;
        }
        
        if (STATUS_INVALID.equals(storedToken.getStatus())) {
            return false;
        }
        
        return !storedToken.getExpireTime().before(new Date());
    }
    
    /**
     * 使令牌失效
     */
    @Transactional
    public void invalidateToken(String token, String tokenType) {
        String encryptedToken = jwtUtils.encryptToken(token);
        Token storedToken = tokenMapper.findByTokenValueAndType(encryptedToken, tokenType);
        
        if (storedToken != null) {
            storedToken.setStatus(STATUS_INVALID);
            storedToken.setRevokeTime(new Date());
            tokenMapper.update(storedToken);
        }
    }
    
    /**
     * 使用户的所有令牌失效
     */
    @Transactional
    public void invalidateAllUserTokens(Integer userId) {
        tokenMapper.invalidateAllByUserId(userId);
    }
    
    /**
     * 使某设备的所有令牌失效
     */
    @Transactional
    public void invalidateDeviceTokens(Integer userId, String deviceId) {
        tokenMapper.invalidateByUserIdAndDevice(userId, deviceId);
    }
    
    /**
     * 清理过期令牌
     */
    @Transactional
    public void cleanupExpiredTokens() {
        tokenMapper.deleteExpiredTokens();
    }
    
    /**
     * 从Access Token获取用户ID
     */
    public Integer getUserIdFromAccessToken(String accessToken) {
        return jwtUtils.getUserIdFromToken(accessToken);
    }
}
```

#### 3.4.2 SmsCodeService（短信验证码服务）

```java
package com.ls.law.service.impl;

import com.ls.law.entity.SmsCode;
import com.ls.law.mapper.SmsCodeMapper;
import com.ls.law.service.SmsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.concurrent.TimeUnit;

@Service
public class SmsCodeService {
    
    @Autowired
    private SmsCodeMapper smsCodeMapper;
    
    @Autowired
    private SmsService smsService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Value("${sms.code.expire:5}")  // 5分钟
    private int smsCodeExpire;
    
    private static final String SMS_TYPE_LOGIN = "1";
    private static final String SMS_TYPE_REGISTER = "2";
    private static final String SMS_TYPE_RESET_PWD = "3";
    private static final String SMS_TYPE_BIND = "4";
    
    private static final String USED_STATUS_NO = "0";
    private static final String USED_STATUS_YES = "1";
    
    /**
     * 发送短信验证码
     */
    @Transactional
    public void sendSmsCode(String mobile, String smsType) {
        // 检查发送频率（1分钟内不能重复发送）
        String frequencyKey = "sms:frequency:" + mobile;
        if (Boolean.TRUE.equals(redisTemplate.hasKey(frequencyKey))) {
            throw new RuntimeException("发送太频繁，请稍后再试");
        }
        
        // 生成6位数字验证码
        String code = String.format("%06d", (int) (Math.random() * 1000000));
        
        // 保存验证码到数据库
        SmsCode smsCode = new SmsCode();
        smsCode.setMobile(mobile);
        smsCode.setCode(code);
        smsCode.setSmsType(smsType);
        smsCode.setExpireTime(new Date(System.currentTimeMillis() + smsCodeExpire * 60 * 1000L));
        smsCode.setUsedStatus(USED_STATUS_NO);
        smsCodeMapper.insert(smsCode);
        
        // 发送短信（根据类型选择模板）
        String templateCode = getTemplateCode(smsType);
        smsService.sendSms(mobile, code, templateCode);
        
        // 设置发送频率限制
        redisTemplate.opsForValue().set(frequencyKey, "1", 1, TimeUnit.MINUTES);
        
        // 缓存验证码到Redis（用于快速验证）
        String cacheKey = "sms:code:" + mobile + ":" + smsType;
        redisTemplate.opsForValue().set(cacheKey, code, smsCodeExpire, TimeUnit.MINUTES);
    }
    
    /**
     * 验证短信验证码
     */
    public boolean verifySmsCode(String mobile, String code, String smsType) {
        // 先从Redis验证
        String cacheKey = "sms:code:" + mobile + ":" + smsType;
        String cachedCode = (String) redisTemplate.opsForValue().get(cacheKey);
        
        if (cachedCode != null && cachedCode.equals(code)) {
            // 标记为已使用
            redisTemplate.delete(cacheKey);
            markSmsCodeUsed(mobile, smsType);
            return true;
        }
        
        // 从数据库验证
        SmsCode smsCode = smsCodeMapper.findByMobileAndType(mobile, smsType);
        
        if (smsCode == null) {
            return false;
        }
        
        if (USED_STATUS_YES.equals(smsCode.getUsedStatus())) {
            return false;
        }
        
        if (smsCode.getExpireTime().before(new Date())) {
            return false;
        }
        
        if (!smsCode.getCode().equals(code)) {
            return false;
        }
        
        // 标记为已使用
        markSmsCodeUsed(mobile, smsType);
        return true;
    }
    
    /**
     * 标记验证码已使用
     */
    @Transactional
    public void markSmsCodeUsed(String mobile, String smsType) {
        SmsCode smsCode = smsCodeMapper.findByMobileAndType(mobile, smsType);
        if (smsCode != null) {
            smsCode.setUsedStatus(USED_STATUS_YES);
            smsCode.setUsedTime(new Date());
            smsCodeMapper.update(smsCode);
        }
    }
    
    /**
     * 检查手机号是否已注册
     */
    public boolean isMobileRegistered(String mobile) {
        return smsCodeMapper.countByMobile(mobile) > 0;
    }
    
    private String getTemplateCode(String smsType) {
        switch (smsType) {
            case SMS_TYPE_LOGIN: return "SMS_123456789";
            case SMS_TYPE_REGISTER: return "SMS_987654321";
            case SMS_TYPE_RESET_PWD: return "SMS_111222333";
            case SMS_TYPE_BIND: return "SMS_444555666";
            default: return "SMS_123456789";
        }
    }
}
```

#### 3.4.3 SmsService（阿里云短信服务）

```java
package com.ls.law.service;

import com.aliyun.dysmsapi20170525.Client;
import com.aliyun.dysmsapi20170525.models.SendSmsRequest;
import com.aliyun.dysmsapi20170525.models.SendSmsResponse;
import com.aliyun.teaopenapi.models.Config;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class SmsService {
    
    private static final Logger logger = LoggerFactory.getLogger(SmsService.class);
    
    @Value("${aliyun.sms.access-key-id}")
    private String accessKeyId;
    
    @Value("${aliyun.sms.access-key-secret}")
    private String accessKeySecret;
    
    @Value("${aliyun.sms.sign-name}")
    private String signName;
    
    private Client client;
    
    private Client getClient() {
        if (client == null) {
            Config config = new Config()
                    .setAccessKeyId(accessKeyId)
                    .setAccessKeySecret(accessKeySecret)
                    .setEndpoint("dysmsapi.aliyuncs.com");
            client = new Client(config);
        }
        return client;
    }
    
    /**
     * 发送短信验证码
     */
    public void sendSms(String mobile, String code, String templateCode) {
        try {
            SendSmsRequest request = new SendSmsRequest()
                    .setSignName(signName)
                    .setTemplateCode(templateCode)
                    .setPhoneNumbers(mobile)
                    .setTemplateParam("{\"code\":\"" + code + "\"}");
            
            SendSmsResponse response = getClient().sendSms(request);
            
            if ("OK".equals(response.getBody().getCode())) {
                logger.info("短信发送成功: mobile={}, code={}", mobile, code);
            } else {
                logger.error("短信发送失败: mobile={}, error={}", mobile, response.getBody().getMessage());
                throw new RuntimeException("短信发送失败: " + response.getBody().getMessage());
            }
        } catch (Exception e) {
            logger.error("短信发送异常: mobile={}", mobile, e);
            throw new RuntimeException("短信发送失败: " + e.getMessage());
        }
    }
}
```

#### 3.4.4 LoginSecurityService（登录安全服务）

```java
package com.ls.law.service.impl;

import com.ls.law.entity.DeviceBinding;
import com.ls.law.entity.LoginRecord;
import com.ls.law.mapper.DeviceBindingMapper;
import com.ls.law.mapper.LoginRecordMapper;
import com.ls.law.mapper.SystemConfigMapper;
import com.ls.law.utils.IpUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.concurrent.TimeUnit;

@Service
public class LoginSecurityService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private LoginRecordMapper loginRecordMapper;
    
    @Autowired
    private DeviceBindingMapper deviceBindingMapper;
    
    @Autowired
    private SystemConfigMapper systemConfigMapper;
    
    private static final String FAIL_COUNT_PREFIX = "login:fail:";
    private static final String LOCK_PREFIX = "login:lock:";
    
    /**
     * 检查登录是否被锁定
     */
    public boolean isLocked(String account, String ip) {
        // 检查账号锁定
        String accountLockKey = LOCK_PREFIX + "account:" + account;
        if (Boolean.TRUE.equals(redisTemplate.hasKey(accountLockKey))) {
            return true;
        }
        
        // 检查IP锁定
        String ipLockKey = LOCK_PREFIX + "ip:" + ip;
        if (Boolean.TRUE.equals(redisTemplate.hasKey(ipLockKey))) {
            return true;
        }
        
        return false;
    }
    
    /**
     * 记录登录失败
     */
    @Transactional
    public void recordLoginFail(String account, String ip, String failType) {
        int maxFailCount = systemConfigMapper.getIntValue("LOGIN_MAX_FAIL_COUNT", 5);
        int lockTime = systemConfigMapper.getIntValue("LOGIN_FAIL_LOCK_TIME", 15);
        
        // 增加失败次数
        String failCountKey = FAIL_COUNT_PREFIX + account;
        Long failCount = redisTemplate.opsForValue().increment(failCountKey);
        
        if (failCount != null && failCount >= maxFailCount) {
            // 锁定账号
            String accountLockKey = LOCK_PREFIX + "account:" + account;
            redisTemplate.opsForValue().set(accountLockKey, "1", lockTime, TimeUnit.MINUTES);
            
            // 锁定IP
            String ipLockKey = LOCK_PREFIX + "ip:" + ip;
            redisTemplate.opsForValue().set(ipLockKey, "1", lockTime, TimeUnit.MINUTES);
            
            // 记录到数据库
            saveLoginFailRecord(account, ip, failCount.intValue(), failType);
        } else {
            // 设置过期时间
            redisTemplate.expire(failCountKey, lockTime, TimeUnit.MINUTES);
        }
    }
    
    /**
     * 清除登录失败记录
     */
    public void clearLoginFail(String account) {
        String failCountKey = FAIL_COUNT_PREFIX + account;
        redisTemplate.delete(failCountKey);
    }
    
    /**
     * 检测登录风险
     */
    public String detectLoginRisk(LoginRecord record) {
        // 检测异地登录
        if (is异地登录(record.getuPid(), record.getLoginIp())) {
            return "3";  // 高风险
        }
        
        // 检测新设备登录
        if (is新设备登录(record.getuPid(), record.getLoginDevice())) {
            return "2";  // 中风险
        }
        
        return "1";  // 低风险
    }
    
    /**
     * 检测是否为异地登录
     */
    private boolean is异地登录(Integer userId, String currentIp) {
        if (userId == null || currentIp == null) {
            return false;
        }
        
        LoginRecord lastRecord = loginRecordMapper.findLastByUserId(userId);
        if (lastRecord != null && lastRecord.getLoginIp() != null) {
            String lastIp = lastRecord.getLoginIp();
            // 简单判断：如果IP不在同一城市，视为异地登录
            String lastLocation = lastRecord.getLoginLocation();
            String currentLocation = IpUtils.getLocationByIp(currentIp);
            
            if (lastLocation != null && currentLocation != null 
                    && !lastLocation.equals(currentLocation)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 检测是否是新设备
     */
    private boolean is新设备登录(Integer userId, String deviceInfo) {
        if (userId == null || deviceInfo == null) {
            return false;
        }
        
        // 从设备信息中提取deviceId
        String deviceId = extractDeviceId(deviceInfo);
        if (deviceId == null) {
            return false;
        }
        
        DeviceBinding binding = deviceBindingMapper.findByUserIdAndDeviceId(userId, deviceId);
        return binding == null;
    }
    
    /**
     * 从设备信息中提取设备ID
     */
    private String extractDeviceId(String deviceInfo) {
        // 解析设备信息JSON，提取deviceId
        try {
            com.alibaba.fastjson.JSONObject obj = 
                    com.alibaba.fastjson.JSON.parseObject(deviceInfo);
            return obj.getString("deviceId");
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * 绑定新设备
     */
    @Transactional
    public void bindNewDevice(DeviceBinding device) {
        deviceBindingMapper.insert(device);
    }
    
    /**
     * 记录登录日志
     */
    @Transactional
    public void saveLoginRecord(LoginRecord record) {
        loginRecordMapper.insert(record);
    }
    
    /**
     * 保存登录失败记录
     */
    @Transactional
    public void saveLoginFailRecord(String account, String ip, int failCount, String failType) {
        // 保存到数据库的登录失败记录表
    }
}
```

#### 3.4.5 更新JwtUtils（增加加密方法）

```java
package com.ls.law.utils;

import io.jsonwebtoken.*;
import org.apache.commons.codec.digest.DigestUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Base64;
import java.util.Date;

@Component
public class JwtUtils {
    
    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.access-token-expire:900000}")
    private long jwtExpiration;
    
    /**
     * 生成JWT令牌
     */
    public String generateToken(Integer userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration);
        
        return Jwts.builder()
                .setSubject(Long.toString(userId))
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }
    
    /**
     * 从JWT令牌中获取用户ID
     */
    public Integer getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
        
        return Integer.parseInt(claims.getSubject());
    }
    
    /**
     * 验证JWT令牌
     */
    public boolean validateToken(String authToken) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
            return true;
        } catch (SignatureException ex) {
        } catch (MalformedJwtException ex) {
        } catch (ExpiredJwtException ex) {
        } catch (UnsupportedJwtException ex) {
        } catch (IllegalArgumentException ex) {
        } catch (Exception ex) {
        }
        return false;
    }
    
    /**
     * 加密令牌（用于数据库存储）
     */
    public String encryptToken(String token) {
        return DigestUtils.md5Hex(token);
    }
    
    /**
     * 从请求头中获取JWT令牌
     */
    public String getTokenFromHeader(String header) {
        if (header != null && header.startsWith("Bearer ")) {
            return header.substring(7);
        }
        return null;
    }
    
    /**
     * 获取令牌过期时间
     */
    public Date getExpirationFromToken(String token) {
        try {
            Claims claims = Jwts.parser()
                    .setSigningKey(jwtSecret)
                    .parseClaimsJws(token)
                    .getBody();
            return claims.getExpiration();
        } catch (Exception e) {
            return null;
        }
    }
}
```

### 3.5 Mapper接口

#### 3.5.1 TokenMapper

```java
package com.ls.law.mapper;

import com.ls.law.entity.Token;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

@Mapper
public interface TokenMapper {
    
    int insert(Token token);
    
    int update(Token token);
    
    Token findByTokenValueAndType(@Param("tokenValue") String tokenValue, 
                                  @Param("tokenType") String tokenType);
    
    Token findByUserIdAndType(@Param("userId") Integer userId, 
                              @Param("tokenType") String tokenType);
    
    int invalidateAllByUserId(@Param("userId") Integer userId);
    
    int invalidateByUserIdAndDevice(@Param("userId") Integer userId, 
                                    @Param("deviceId") String deviceId);
    
    int deleteExpiredTokens();
    
    int deleteByUserIdAndType(@Param("userId") Integer userId, 
                              @Param("tokenType") String tokenType);
}
```

#### 3.5.2 TokenMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ls.law.mapper.TokenMapper">
    
    <resultMap id="BaseResultMap" type="com.ls.law.entity.Token">
        <id column="token_id" property="tokenId"/>
        <result column="u_pid" property="uPid"/>
        <result column="token_type" property="tokenType"/>
        <result column="token_value" property="tokenValue"/>
        <result column="device_id" property="deviceId"/>
        <result column="device_info" property="deviceInfo"/>
        <result column="ip_address" property="ipAddress"/>
        <result column="expire_time" property="expireTime"/>
        <result column="create_time" property="createTime"/>
        <result column="revoke_time" property="revokeTime"/>
        <result column="status" property="status"/>
    </resultMap>
    
    <sql id="Base_Column_List">
        token_id, u_pid, token_type, token_value, device_id, device_info, 
        ip_address, expire_time, create_time, revoke_time, status
    </sql>
    
    <insert id="insert" parameterType="com.ls.law.entity.Token" useGeneratedKeys="true" keyProperty="tokenId">
        INSERT INTO TB_TOKEN (u_pid, token_type, token_value, device_id, device_info, 
                             ip_address, expire_time, status)
        VALUES (#{uPid}, #{tokenType}, #{tokenValue}, #{deviceId}, #{deviceInfo},
                #{ipAddress}, #{expireTime}, #{status})
    </insert>
    
    <update id="update" parameterType="com.ls.law.entity.Token">
        UPDATE TB_TOKEN
        <set>
            <if test="status != null">status = #{status},</if>
            <if test="revokeTime != null">revoke_time = #{revokeTime},</if>
        </set>
        WHERE token_id = #{tokenId}
    </update>
    
    <select id="findByTokenValueAndType" resultMap="BaseResultMap">
        SELECT <include refid="Base_Column_List"/>
        FROM TB_TOKEN
        WHERE token_value = #{tokenValue} AND token_type = #{tokenType}
    </select>
    
    <select id="findByUserIdAndType" resultMap="BaseResultMap">
        SELECT <include refid="Base_Column_List"/>
        FROM TB_TOKEN
        WHERE u_pid = #{userId} AND token_type = #{tokenType} AND status = '1'
    </select>
    
    <update id="invalidateAllByUserId">
        UPDATE TB_TOKEN
        SET status = '0', revoke_time = GETDATE()
        WHERE u_pid = #{userId} AND status = '1'
    </update>
    
    <update id="invalidateByUserIdAndDevice">
        UPDATE TB_TOKEN
        SET status = '0', revoke_time = GETDATE()
        WHERE u_pid = #{userId} AND device_id = #{deviceId} AND status = '1'
    </update>
    
    <delete id="deleteExpiredTokens">
        DELETE FROM TB_TOKEN WHERE expire_time &lt; GETDATE() AND status = '1'
    </delete>
    
</mapper>
```

#### 3.5.3 SmsCodeMapper

```java
package com.ls.law.mapper;

import com.ls.law.entity.SmsCode;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

@Mapper
public interface SmsCodeMapper {
    
    int insert(SmsCode smsCode);
    
    int update(SmsCode smsCode);
    
    SmsCode findByMobileAndType(@Param("mobile") String mobile, 
                                 @Param("smsType") String smsType);
    
    int countByMobile(@Param("mobile") String mobile);
    
    SmsCode findLatestByMobileAndType(@Param("mobile") String mobile, 
                                       @Param("smsType") String smsType);
}
```

#### 3.5.4 SmsCodeMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ls.law.mapper.SmsCodeMapper">
    
    <resultMap id="BaseResultMap" type="com.ls.law.entity.SmsCode">
        <id column="sms_id" property="smsId"/>
        <result column="mobile" property="mobile"/>
        <result column="code" property="code"/>
        <result column="sms_type" property="smsType"/>
        <result column="expire_time" property="expireTime"/>
        <result column="used_time" property="usedTime"/>
        <result column="used_status" property="usedStatus"/>
        <result column="create_time" property="createTime"/>
    </resultMap>
    
    <sql id="Base_Column_List">
        sms_id, mobile, code, sms_type, expire_time, used_time, used_status, create_time
    </sql>
    
    <insert id="insert" parameterType="com.ls.law.entity.SmsCode" useGeneratedKeys="true" keyProperty="smsId">
        INSERT INTO TB_SMS_CODE (mobile, code, sms_type, expire_time, used_status)
        VALUES (#{mobile}, #{code}, #{smsType}, #{expireTime}, #{usedStatus})
    </insert>
    
    <update id="update" parameterType="com.ls.law.entity.SmsCode">
        UPDATE TB_SMS_CODE
        <set>
            <if test="usedStatus != null">used_status = #{usedStatus},</if>
            <if test="usedTime != null">used_time = #{usedTime},</if>
        </set>
        WHERE sms_id = #{smsId}
    </update>
    
    <select id="findByMobileAndType" resultMap="BaseResultMap">
        SELECT TOP 1 <include refid="Base_Column_List"/>
        FROM TB_SMS_CODE
        WHERE mobile = #{mobile} AND sms_type = #{smsType}
        ORDER BY create_time DESC
    </select>
    
    <select id="countByMobile" resultType="int">
        SELECT COUNT(1) FROM TB_USER WHERE u_mobile = #{mobile}
    </select>
    
</mapper>
```

#### 3.5.5 LoginRecordMapper

```java
package com.ls.law.mapper;

import com.ls.law.entity.LoginRecord;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;

@Mapper
public interface LoginRecordMapper {
    
    int insert(LoginRecord record);
    
    List<LoginRecord> findByUserId(@Param("userId") Integer userId);
    
    LoginRecord findLastByUserId(@Param("userId") Integer userId);
    
    List<LoginRecord> findByUserIdAndTimeRange(@Param("userId") Integer userId,
                                                @Param("startTime") java.util.Date startTime,
                                                @Param("endTime") java.util.Date endTime);
    
    int countByUserIdAndStatus(@Param("userId") Integer userId, 
                               @Param("status") String status);
}
```

#### 3.5.6 其他Mapper

```java
// RoleMapper
@Mapper
public interface RoleMapper {
    List<Role> findAll();
    List<Role> findByUserId(Integer userId);
    Role findById(Integer roleId);
    int insert(Role role);
    int update(Role role);
    int delete(Integer roleId);
}

// PermissionMapper
@Mapper
public interface PermissionMapper {
    List<Permission> findAll();
    List<Permission> findByRoleId(Integer roleId);
    List<Permission> findMenuTree();
    Permission findById(Integer permId);
    int insert(Permission permission);
    int update(Permission permission);
    int delete(Integer permId);
}

// UserRoleMapper
@Mapper
public interface UserRoleMapper {
    int insert(@Param("userId") Integer userId, @Param("roleId") Integer roleId);
    int deleteByUserId(Integer userId);
    List<Integer> findRoleIdsByUserId(Integer userId);
}

// RolePermissionMapper
@Mapper
public interface RolePermissionMapper {
    int insert(@Param("roleId") Integer roleId, @Param("permId") Integer permId);
    int deleteByRoleId(Integer roleId);
    List<Integer> findPermIdsByRoleId(Integer roleId);
}

// DeviceBindingMapper
@Mapper
public interface DeviceBindingMapper {
    int insert(DeviceBinding binding);
    int update(DeviceBinding binding);
    int delete(Integer bindingId);
    DeviceBinding findByUserIdAndDeviceId(@Param("userId") Integer userId, 
                                          @Param("deviceId") String deviceId);
    List<DeviceBinding> findByUserId(Integer userId);
    List<DeviceBinding> findTrustedByUserId(Integer userId);
}

// SystemConfigMapper
@Mapper
public interface SystemConfigMapper {
    String getValue(String configKey);
    int getIntValue(String configKey, int defaultValue);
    int updateValue(@Param("configKey") String configKey, @Param("configValue") String configValue);
}
```

### 3.6 Service层

#### 3.6.1 AuthService（认证服务）

```java
package com.ls.law.service;

import com.ls.law.entity.*;
import com.ls.law.mapper.*;
import com.ls.law.model.Result;
import com.ls.law.service.impl.*;
import com.ls.law.utils.IpUtils;
import com.ls.law.utils.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;

@Service
public class AuthService {
    
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private JwtTokenService jwtTokenService;
    
    @Autowired
    private SmsCodeService smsCodeService;
    
    @Autowired
    private LoginSecurityService loginSecurityService;
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Value("${jwt.access-token-expire:900000}")
    private long accessTokenExpire;
    
    /**
     * 用户名密码登录
     */
    @Transactional
    public Map<String, Object> loginByPassword(String username, String password, 
            String deviceId, String deviceInfo, String ipAddress, String userAgent) {
        Map<String, Object> result = new HashMap<>();
        
        // 检查登录是否被锁定
        if (loginSecurityService.isLocked(username, ipAddress)) {
            throw new RuntimeException("登录已被锁定，请15分钟后重试");
        }
        
        // 验证用户名密码
        User user = userMapper.findByUsername(username);
        
        if (user == null) {
            loginSecurityService.recordLoginFail(username, ipAddress, "1");
            throw new RuntimeException("用户名或密码错误");
        }
        
        // 验证密码（MD5加密对比）
        String encryptedPassword = org.apache.commons.codec.digest.DigestUtils.md5Hex(password);
        if (!encryptedPassword.equals(user.getuPwd())) {
            loginSecurityService.recordLoginFail(username, ipAddress, "1");
            throw new RuntimeException("用户名或密码错误");
        }
        
        // 验证用户状态
        if (!"1".equals(user.getuStatus())) {
            throw new RuntimeException("用户已被禁用，请联系管理员");
        }
        
        // 验证设备绑定
        if (!verifyDeviceBinding(user, deviceId, deviceInfo)) {
            throw new RuntimeException("设备未绑定，请先绑定设备");
        }
        
        // 生成令牌
        Map<String, Object> tokens = jwtTokenService.generateTokens(
                user.getuPid(), deviceId, deviceInfo, ipAddress);
        
        // 更新用户登录信息
        user.setuLastLoginTime(new Date());
        user.setuLastLoginIp(ipAddress);
        user.setuLoginCount(user.getuLoginCount() + 1);
        user.setuPwdErrorCount(0);
        userMapper.update(user);
        
        // 清除登录失败记录
        loginSecurityService.clearLoginFail(username);
        
        // 记录登录日志
        LoginRecord record = createLoginRecord(user, "1", deviceId, deviceInfo, 
                ipAddress, userAgent, "1");
        loginSecurityService.saveLoginRecord(record);
        
        // 构建响应
        result.put("accessToken", tokens.get("accessToken"));
        result.put("accessTokenExpire", accessTokenExpire);
        result.put("refreshToken", tokens.get("refreshToken"));
        result.put("refreshTokenExpire", tokens.get("refreshTokenExpire"));
        result.put("user", buildUserInfo(user));
        
        return result;
    }
    
    /**
     * 手机验证码登录
     */
    @Transactional
    public Map<String, Object> loginBySms(String mobile, String smsCode,
            String deviceId, String deviceInfo, String ipAddress, String userAgent) {
        Map<String, Object> result = new HashMap<>();
        
        // 检查登录是否被锁定
        if (loginSecurityService.isLocked(mobile, ipAddress)) {
            throw new RuntimeException("登录已被锁定，请15分钟后重试");
        }
        
        // 验证短信验证码
        if (!smsCodeService.verifySmsCode(mobile, smsCode, "1")) {
            loginSecurityService.recordLoginFail(mobile, ipAddress, "2");
            throw new RuntimeException("验证码错误或已过期");
        }
        
        // 获取用户
        User user = userMapper.findByMobile(mobile);
        
        if (user == null) {
            throw new RuntimeException("该手机号未绑定账号");
        }
        
        // 验证用户状态
        if (!"1".equals(user.getuStatus())) {
            throw new RuntimeException("用户已被禁用，请联系管理员");
        }
        
        // 生成令牌
        Map<String, Object> tokens = jwtTokenService.generateTokens(
                user.getuPid(), deviceId, deviceInfo, ipAddress);
        
        // 更新用户登录信息
        user.setuLastLoginTime(new Date());
        user.setuLastLoginIp(ipAddress);
        user.setuLoginCount(user.getuLoginCount() + 1);
        userMapper.update(user);
        
        // 清除登录失败记录
        loginSecurityService.clearLoginFail(mobile);
        
        // 记录登录日志
        LoginRecord record = createLoginRecord(user, "2", deviceId, deviceInfo, 
                ipAddress, userAgent, "1");
        loginSecurityService.saveLoginRecord(record);
        
        // 构建响应
        result.put("accessToken", tokens.get("accessToken"));
        result.put("accessTokenExpire", accessTokenExpire);
        result.put("refreshToken", tokens.get("refreshToken"));
        result.put("refreshTokenExpire", tokens.get("refreshTokenExpire"));
        result.put("user", buildUserInfo(user));
        
        return result;
    }
    
    /**
     * 刷新令牌
     */
    public Map<String, Object> refreshToken(String refreshToken, String deviceId,
            String deviceInfo, String ipAddress) {
        return jwtTokenService.refreshAccessToken(refreshToken, deviceId, deviceInfo, ipAddress);
    }
    
    /**
     * 登出
     */
    @Transactional
    public void logout(String accessToken, String refreshToken) {
        if (accessToken != null) {
            jwtTokenService.invalidateToken(accessToken, "1");
        }
        if (refreshToken != null) {
            jwtTokenService.invalidateToken(refreshToken, "2");
        }
    }
    
    /**
     * 验证设备绑定
     */
    private boolean verifyDeviceBinding(User user, String deviceId, String deviceInfo) {
        // 如果未启用设备绑定，直接通过
        // 从系统配置获取是否启用设备绑定
        return true;
    }
    
    /**
     * 创建登录记录
     */
    private LoginRecord createLoginRecord(User user, String loginType,
            String deviceId, String deviceInfo, String ipAddress, 
            String userAgent, String loginStatus) {
        LoginRecord record = new LoginRecord();
        record.setuPid(user.getuPid());
        record.setuUser(user.getuUser());
        record.setuName(user.getuName());
        record.setLoginType(loginType);
        record.setLoginIp(ipAddress);
        record.setLoginLocation(IpUtils.getLocationByIp(ipAddress));
        record.setLoginDevice(deviceInfo);
        record.setLoginBrowser(IpUtils.getBrowserInfo(userAgent));
        record.setLoginOs(IpUtils.getOsInfo(userAgent));
        record.setLoginStatus(loginStatus);
        record.setRiskLevel(loginSecurityService.detectLoginRisk(record));
        return record;
    }
    
    /**
     * 构建用户信息（脱敏）
     */
    private Map<String, Object> buildUserInfo(User user) {
        Map<String, Object> userInfo = new HashMap<>();
        userInfo.put("uPid", user.getuPid());
        userInfo.put("uUser", user.getuUser());
        userInfo.put("uName", user.getuName());
        userInfo.put("uDept", user.getuDept());
        userInfo.put("uTel", user.getuTel());
        userInfo.put("uMobile", user.getuMobile());
        userInfo.put("uEmail", user.getuEmail());
        return userInfo;
    }
}
```

#### 3.6.2 PermissionService（权限服务）

```java
package com.ls.law.service;

import com.ls.law.entity.*;
import com.ls.law.mapper.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class PermissionService {
    
    @Autowired
    private UserRoleMapper userRoleMapper;
    
    @Autowired
    private RolePermissionMapper rolePermissionMapper;
    
    @Autowired
    private PermissionMapper permissionMapper;
    
    @Autowired
    private RoleMapper roleMapper;
    
    /**
     * 获取用户的所有权限编码
     */
    public Set<String> getUserPermissions(Integer userId) {
        // 获取用户角色
        List<Integer> roleIds = userRoleMapper.findRoleIdsByUserId(userId);
        
        if (roleIds.isEmpty()) {
            return new HashSet<>();
        }
        
        // 获取所有角色的权限
        Set<String> permissions = new HashSet<>();
        for (Integer roleId : roleIds) {
            List<Integer> permIds = rolePermissionMapper.findPermIdsByRoleId(roleId);
            for (Integer permId : permIds) {
                Permission perm = permissionMapper.findById(permId);
                if (perm != null && "1".equals(perm.getStatus())) {
                    permissions.add(perm.getPermCode());
                }
            }
        }
        
        return permissions;
    }
    
    /**
     * 获取用户的菜单树
     */
    public List<Permission> getUserMenuTree(Integer userId) {
        // 获取用户权限ID
        Set<String> permCodes = getUserPermissions(userId);
        
        // 获取所有菜单权限
        List<Permission> allMenus = permissionMapper.findAll().stream()
                .filter(p -> "1".equals(p.getPermType()))
                .filter(p -> permCodes.contains(p.getPermCode()) || "SUPER_ADMIN".equals(getUserRoleCode(userId)))
                .collect(Collectors.toList());
        
        // 构建树形结构
        return buildMenuTree(allMenus, 0);
    }
    
    /**
     * 获取用户角色编码
     */
    private String getUserRoleCode(Integer userId) {
        List<Role> roles = roleMapper.findByUserId(userId);
        return roles.stream()
                .filter(r -> "1".equals(r.getStatus()))
                .map(Role::getRoleCode)
                .findFirst()
                .orElse(null);
    }
    
    /**
     * 构建菜单树
     */
    private List<Permission> buildMenuTree(List<Permission> menus, int parentId) {
        return menus.stream()
                .filter(m -> m.getParentId().equals(parentId))
                .peek(m -> m.setChildren(buildMenuTree(menus, m.getPermId())))
                .sorted(Comparator.comparingInt(Permission::getSortOrder))
                .collect(Collectors.toList());
    }
    
    /**
     * 检查用户是否有某个权限
     */
    public boolean hasPermission(Integer userId, String permCode) {
        // 超级管理员拥有所有权限
        if (isSuperAdmin(userId)) {
            return true;
        }
        return getUserPermissions(userId).contains(permCode);
    }
    
    /**
     * 检查是否是超级管理员
     */
    private boolean isSuperAdmin(Integer userId) {
        List<Role> roles = roleMapper.findByUserId(userId);
        return roles.stream()
                .anyMatch(r -> "SUPER_ADMIN".equals(r.getRoleCode()) && "1".equals(r.getStatus()));
    }
}
```

### 3.7 Controller层

#### 3.7.1 AuthController（认证控制器）

```java
package com.ls.law.controller;

import com.ls.law.entity.User;
import com.ls.law.mapper.UserMapper;
import com.ls.law.model.Result;
import com.ls.law.service.AuthService;
import com.ls.law.service.PermissionService;
import com.ls.law.service.SmsCodeService;
import com.ls.law.utils.IpUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/web")
public class AuthController {
    
    @Autowired
    private AuthService authService;
    
    @Autowired
    private SmsCodeService smsCodeService;
    
    @Autowired
    private PermissionService permissionService;
    
    @Autowired
    private UserMapper userMapper;
    
    /**
     * 用户名密码登录
     */
    @PostMapping("/login")
    public Result login(@RequestBody Map<String, String> params, 
                       HttpServletRequest request) {
        try {
            String username = params.get("username");
            String password = params.get("password");
            String deviceId = params.get("deviceId");
            String deviceInfo = params.get("deviceInfo");
            
            if (username == null || password == null) {
                return Result.error("用户名和密码不能为空");
            }
            
            String ipAddress = IpUtils.getClientIp(request);
            String userAgent = request.getHeader("User-Agent");
            
            Map<String, Object> result = authService.loginByPassword(
                    username, password, deviceId, deviceInfo, ipAddress, userAgent);
            
            return Result.success("登录成功", result);
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
    
    /**
     * 手机验证码登录-发送验证码
     */
    @PostMapping("/sendLoginSms")
    public Result sendLoginSms(@RequestBody Map<String, String> params) {
        try {
            String mobile = params.get("mobile");
            
            if (mobile == null || !mobile.matches("^1[3-9]\\d{9}$")) {
                return Result.error("手机号格式不正确");
            }
            
            // 检查手机号是否已注册
            User user = userMapper.findByMobile(mobile);
            if (user == null) {
                return Result.error("该手机号未绑定账号");
            }
            
            smsCodeService.sendSmsCode(mobile, "1");
            
            return Result.success("验证码发送成功");
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
    
    /**
     * 手机验证码登录
     */
    @PostMapping("/loginBySms")
    public Result loginBySms(@RequestBody Map<String, String> params,
                            HttpServletRequest request) {
        try {
            String mobile = params.get("mobile");
            String smsCode = params.get("smsCode");
            String deviceId = params.get("deviceId");
            String deviceInfo = params.get("deviceInfo");
            
            if (mobile == null || smsCode == null) {
                return Result.error("手机号和验证码不能为空");
            }
            
            String ipAddress = IpUtils.getClientIp(request);
            String userAgent = request.getHeader("User-Agent");
            
            Map<String, Object> result = authService.loginBySms(
                    mobile, smsCode, deviceId, deviceInfo, ipAddress, userAgent);
            
            return Result.success("登录成功", result);
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
    
    /**
     * 刷新令牌
     */
    @PostMapping("/refreshToken")
    public Result refreshToken(@RequestBody Map<String, String> params,
                              HttpServletRequest request) {
        try {
            String refreshToken = params.get("refreshToken");
            String deviceId = params.get("deviceId");
            
            if (refreshToken == null) {
                return Result.error("Refresh Token不能为空");
            }
            
            String deviceInfo = request.getHeader("User-Agent");
            String ipAddress = IpUtils.getClientIp(request);
            
            Map<String, Object> result = authService.refreshToken(
                    refreshToken, deviceId, deviceInfo, ipAddress);
            
            return Result.success("令牌刷新成功", result);
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
    
    /**
     * 登出
     */
    @PostMapping("/logout")
    public Result logout(@RequestBody Map<String, String> params,
                        @RequestHeader(value = "Authorization", required = false) String authHeader) {
        try {
            String refreshToken = params.get("refreshToken");
            String accessToken = authHeader != null ? 
                    authHeader.replace("Bearer ", "") : null;
            
            authService.logout(accessToken, refreshToken);
            
            return Result.success("登出成功");
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
    
    /**
     * 获取当前用户信息
     */
    @GetMapping("/currentUser")
    public Result getCurrentUser(@RequestHeader("Authorization") String authHeader) {
        try {
            String token = authHeader.replace("Bearer ", "");
            Integer userId = permissionService.hasPermission(
                    com.ls.law.utils.JwtUtils.getUserIdFromToken(token));
            
            User user = userMapper.findById(userId);
            
            Map<String, Object> userInfo = new HashMap<>();
            userInfo.put("uPid", user.getuPid());
            userInfo.put("uUser", user.getuUser());
            userInfo.put("uName", user.getuName());
            userInfo.put("uDept", user.getuDept());
            userInfo.put("uTel", user.getuTel());
            userInfo.put("uMobile", user.getuMobile());
            userInfo.put("uEmail", user.getuEmail());
            
            return Result.success("获取成功", userInfo);
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
    
    /**
     * 获取当前用户权限信息
     */
    @GetMapping("/permissions")
    public Result getPermissions(@RequestHeader("Authorization") String authHeader) {
        try {
            String token = authHeader.replace("Bearer ", "");
            Integer userId = com.ls.law.utils.JwtUtils.getUserIdFromToken(token);
            
            Map<String, Object> result = new HashMap<>();
            result.put("permissions", permissionService.getUserPermissions(userId));
            result.put("menus", permissionService.getUserMenuTree(userId));
            
            return Result.success("获取成功", result);
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
}
```

#### 3.7.2 SmsController（短信控制器）

```java
package com.ls.law.controller;

import com.ls.law.service.SmsCodeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/web")
public class SmsController {
    
    @Autowired
    private SmsCodeService smsCodeService;
    
    /**
     * 发送注册验证码
     */
    @PostMapping("/sendRegisterSms")
    public Result sendRegisterSms(@RequestBody Map<String, String> params) {
        try {
            String mobile = params.get("mobile");
            
            if (mobile == null || !mobile.matches("^1[3-9]\\d{9}$")) {
                return Result.error("手机号格式不正确");
            }
            
            smsCodeService.sendSmsCode(mobile, "2");
            
            return Result.success("验证码发送成功");
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
    
    /**
     * 发送重置密码验证码
     */
    @PostMapping("/sendResetPwdSms")
    public Result sendResetPwdSms(@RequestBody Map<String, String> params) {
        try {
            String mobile = params.get("mobile");
            
            if (mobile == null || !mobile.matches("^1[3-9]\\d{9}$")) {
                return Result.error("手机号格式不正确");
            }
            
            smsCodeService.sendSmsCode(mobile, "3");
            
            return Result.success("验证码发送成功");
        } catch (Exception e) {
            return Result.error(e.getMessage());
        }
    }
}
```

### 3.8 配置类

#### 3.8.1 JwtInterceptor（JWT拦截器）

```java
package com.ls.law.config;

import com.ls.law.model.Result;
import com.ls.law.service.JwtTokenService;
import com.ls.law.utils.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class JwtInterceptor implements HandlerInterceptor {
    
    @Autowired
    private JwtTokenService jwtTokenService;
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 排除的路径
        String[] excludePaths = {
            "/api/web/login",
            "/api/web/loginBySms",
            "/api/web/sendLoginSms",
            "/api/web/sendRegisterSms",
            "/api/web/sendResetPwdSms",
            "/api/web/refreshToken"
        };
        
        String requestPath = request.getRequestURI();
        for (String path : excludePaths) {
            if (requestPath.equals(path)) {
                return true;
            }
        }
        
        // 获取Authorization头
        String authHeader = request.getHeader("Authorization");
        
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            writeUnauthorizedResponse(response, "未提供认证令牌");
            return false;
        }
        
        String token = authHeader.substring(7);
        
        // 验证令牌
        if (!jwtTokenService.validateAccessToken(token)) {
            writeUnauthorizedResponse(response, "令牌无效或已过期");
            return false;
        }
        
        // 将用户ID放入请求属性
        Integer userId = jwtUtils.getUserIdFromToken(token);
        request.setAttribute("userId", userId);
        
        return true;
    }
    
    private void writeUnauthorizedResponse(HttpServletResponse response, String message) {
        response.setContentType("application/json;charset=UTF-8");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        try {
            response.getWriter().write("{\"status\":\"0\",\"msg\":\"" + message + "\",\"code\":401}");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### 3.8.2 WebConfig（Web配置）

```java
package com.ls.law.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.*;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private JwtInterceptor jwtInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(jwtInterceptor)
                .addPathPatterns("/api/web/**")
                .excludePathPatterns(
                    "/api/web/login",
                    "/api/web/loginBySms",
                    "/api/web/sendLoginSms",
                    "/api/web/sendRegisterSms",
                    "/api/web/sendResetPwdSms",
                    "/api/web/refreshToken"
                );
    }
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOriginPatterns("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

#### 3.8.3 RedisConfig（Redis配置）

```java
package com.ls.law.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        // 使用Jackson序列化
        Jackson2JsonRedisSerializer<Object> jsonSerializer = 
                new Jackson2JsonRedisSerializer<>(Object.class);
        
        // key使用String序列化
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        
        // value使用JSON序列化
        template.setValueSerializer(jsonSerializer);
        template.setHashValueSerializer(jsonSerializer);
        
        template.afterPropertiesSet();
        return template;
    }
}
```

---

## 四、前端实现

### 4.1 API服务层

#### 4.1.1 api.js（基础API服务）

```javascript
// src/services/api.js

const API_BASE_URL = process.env.VUE_APP_API_BASE_URL || 'http://localhost:8080/api/web';

class ApiService {
    constructor() {
        this.accessToken = localStorage.getItem('accessToken');
        this.refreshToken = localStorage.getItem('refreshToken');
        this.deviceId = this.getDeviceId();
    }
    
    getDeviceId() {
        let deviceId = localStorage.getItem('deviceId');
        if (!deviceId) {
            deviceId = this.generateDeviceId();
            localStorage.setItem('deviceId', deviceId);
        }
        return deviceId;
    }
    
    generateDeviceId() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    
    getDeviceInfo() {
        const ua = navigator.userAgent;
        return JSON.stringify({
            deviceId: this.deviceId,
            browser: this.getBrowserInfo(ua),
            os: this.getOsInfo(ua),
            platform: navigator.platform
        });
    }
    
    getBrowserInfo(ua) {
        if (ua.indexOf('Firefox') > -1) return 'Firefox';
        if (ua.indexOf('Chrome') > -1) return 'Chrome';
        if (ua.indexOf('Safari') > -1) return 'Safari';
        if (ua.indexOf('Edge') > -1) return 'Edge';
        return 'Unknown';
    }
    
    getOsInfo(ua) {
        if (ua.indexOf('Windows') > -1) return 'Windows';
        if (ua.indexOf('Mac') > -1) return 'macOS';
        if (ua.indexOf('Linux') > -1) return 'Linux';
        if (ua.indexOf('Android') > -1) return 'Android';
        if (ua.indexOf('iOS') > -1) return 'iOS';
        return 'Unknown';
    }
    
    async request(url, options = {}) {
        const headers = {
            'Content-Type': 'application/json',
            ...options.headers
        };
        
        // 添加Access Token
        if (this.accessToken) {
            headers['Authorization'] = `Bearer ${this.accessToken}`;
        }
        
        const response = await fetch(`${API_BASE_URL}${url}`, {
            ...options,
            headers
        });
        
        const data = await response.json();
        
        // 处理401错误（令牌过期）
        if (response.status === 401) {
            // 尝试刷新令牌
            const refreshed = await this.refreshAccessToken();
            if (refreshed) {
                // 重新发起请求
                return this.request(url, options);
            } else {
                // 刷新失败，跳转登录
                this.logout();
                window.location.href = '/login';
            }
        }
        
        return data;
    }
    
    async refreshAccessToken() {
        if (!this.refreshToken) return false;
        
        try {
            const response = await fetch(`${API_BASE_URL}/refreshToken`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    refreshToken: this.refreshToken,
                    deviceId: this.deviceId
                })
            });
            
            const data = await response.json();
            
            if (data.status === '1') {
                this.accessToken = data.data.accessToken;
                this.refreshToken = data.data.refreshToken;
                localStorage.setItem('accessToken', this.accessToken);
                localStorage.setItem('refreshToken', this.refreshToken);
                return true;
            }
        } catch (e) {
            console.error('刷新令牌失败:', e);
        }
        
        return false;
    }
    
    async login(username, password) {
        const response = await fetch(`${API_BASE_URL}/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                username,
                password,
                deviceId: this.deviceId,
                deviceInfo: this.getDeviceInfo()
            })
        });
        
        const data = await response.json();
        
        if (data.status === '1') {
            this.accessToken = data.data.accessToken;
            this.refreshToken = data.data.refreshToken;
            localStorage.setItem('accessToken', this.accessToken);
            localStorage.setItem('refreshToken', this.refreshToken);
            localStorage.setItem('user', JSON.stringify(data.data.user));
            return { success: true, user: data.data.user };
        }
        
        return { success: false, message: data.msg || data.data };
    }
    
    async sendLoginSms(mobile) {
        return this.request('/sendLoginSms', {
            method: 'POST',
            body: JSON.stringify({ mobile })
        });
    }
    
    async loginBySms(mobile, smsCode) {
        const response = await fetch(`${API_BASE_URL}/loginBySms`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                mobile,
                smsCode,
                deviceId: this.deviceId,
                deviceInfo: this.getDeviceInfo()
            })
        });
        
        const data = await response.json();
        
        if (data.status === '1') {
            this.accessToken = data.data.accessToken;
            this.refreshToken = data.data.refreshToken;
            localStorage.setItem('accessToken', this.accessToken);
            localStorage.setItem('refreshToken', this.refreshToken);
            localStorage.setItem('user', JSON.stringify(data.data.user));
            return { success: true, user: data.data.user };
        }
        
        return { success: false, message: data.msg || data.data };
    }
    
    async logout() {
        try {
            await this.request('/logout', {
                method: 'POST',
                body: JSON.stringify({ refreshToken: this.refreshToken })
            });
        } catch (e) {
            console.error('登出请求失败:', e);
        }
        
        this.accessToken = null;
        this.refreshToken = null;
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('user');
    }
    
    async getCurrentUser() {
        return this.request('/currentUser');
    }
    
    async getPermissions() {
        return this.request('/permissions');
    }
    
    async get(url, params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const urlWithParams = queryString ? `${url}?${queryString}` : url;
        return this.request(urlWithParams);
    }
    
    async post(url, data = {}) {
        return this.request(url, {
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
}

export const api = new ApiService();
export default api;
```

### 4.2 Vue实现示例

#### 4.2.1 Login.vue（登录组件）

```vue
<template>
  <div class="login-container">
    <div class="login-box">
      <h2>法律案件管理系统</h2>
      
      <!-- 登录方式切换 -->
      <div class="login-type-tabs">
        <span 
          :class="{ active: loginType === 'password' }" 
          @click="loginType = 'password'"
        >密码登录</span>
        <span 
          :class="{ active: loginType === 'sms' }" 
          @click="loginType = 'sms'"
        >短信登录</span>
      </div>
      
      <!-- 密码登录表单 -->
      <form v-if="loginType === 'password'" @submit.prevent="handlePasswordLogin">
        <div class="form-group">
          <label>用户名</label>
          <input 
            type="text" 
            v-model="passwordForm.username" 
            placeholder="请输入用户名"
            required
          >
        </div>
        
        <div class="form-group">
          <label>密码</label>
          <input 
            type="password" 
            v-model="passwordForm.password" 
            placeholder="请输入密码"
            required
          >
        </div>
        
        <div class="form-group">
          <button type="submit" :disabled="loading">
            {{ loading ? '登录中...' : '登 录' }}
          </button>
        </div>
      </form>
      
      <!-- 短信登录表单 -->
      <form v-if="loginType === 'sms'" @submit.prevent="handleSmsLogin">
        <div class="form-group">
          <label>手机号</label>
          <input 
            type="tel" 
            v-model="smsForm.mobile" 
            placeholder="请输入手机号"
            maxlength="11"
            required
          >
        </div>
        
        <div class="form-group captcha-group">
          <label>验证码</label>
          <div class="captcha-input">
            <input 
              type="text" 
              v-model="smsForm.code" 
              placeholder="请输入验证码"
              maxlength="6"
              required
            >
            <button 
              type="button" 
              class="send-btn" 
              @click="sendSmsCode"
              :disabled="smsCountdown > 0"
            >
              {{ smsCountdown > 0 ? `${smsCountdown}s后重发` : '获取验证码' }}
            </button>
          </div>
        </div>
        
        <div class="form-group">
          <button type="submit" :disabled="loading">
            {{ loading ? '登录中...' : '登 录' }}
          </button>
        </div>
      </form>
      
      <div v-if="error" class="error-message">
        {{ error }}
      </div>
    </div>
  </div>
</template>

<script>
import api from '@/services/api';

export default {
  name: 'Login',
  data() {
    return {
      loginType: 'password',
      loading: false,
      error: '',
      passwordForm: {
        username: '',
        password: ''
      },
      smsForm: {
        mobile: '',
        code: ''
      },
      smsCountdown: 0
    };
  },
  methods: {
    async handlePasswordLogin() {
      this.loading = true;
      this.error = '';
      
      try {
        const result = await api.login(
          this.passwordForm.username,
          this.passwordForm.password
        );
        
        if (result.success) {
          this.$message.success('登录成功');
          this.$router.push('/home');
        } else {
          this.error = result.message;
        }
      } catch (e) {
        this.error = '登录失败，请检查网络连接';
      } finally {
        this.loading = false;
      }
    },
    
    async sendSmsCode() {
      if (!/^1[3-9]\d{9}$/.test(this.smsForm.mobile)) {
        this.error = '请输入正确的手机号';
        return;
      }
      
      try {
        const result = await api.sendLoginSms(this.smsForm.mobile);
        
        if (result.status === '1') {
          this.startSmsCountdown();
          this.$message.success('验证码已发送');
        } else {
          this.error = result.msg;
        }
      } catch (e) {
        this.error = '验证码发送失败';
      }
    },
    
    startSmsCountdown() {
      this.smsCountdown = 60;
      const timer = setInterval(() => {
        this.smsCountdown--;
        if (this.smsCountdown <= 0) {
          clearInterval(timer);
        }
      }, 1000);
    },
    
    async handleSmsLogin() {
      this.loading = true;
      this.error = '';
      
      try {
        const result = await api.loginBySms(
          this.smsForm.mobile,
          this.smsForm.code
        );
        
        if (result.success) {
          this.$message.success('登录成功');
          this.$router.push('/home');
        } else {
          this.error = result.message;
        }
      } catch (e) {
        this.error = '登录失败，请检查网络连接';
      } finally {
        this.loading = false;
      }
    }
  }
};
</script>

<style scoped>
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.login-box {
  width: 400px;
  padding: 40px;
  background: #fff;
  border-radius: 10px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
}

.login-box h2 {
  text-align: center;
  margin-bottom: 30px;
  color: #333;
}

.login-type-tabs {
  display: flex;
  justify-content: center;
  margin-bottom: 30px;
  border-bottom: 1px solid #eee;
}

.login-type-tabs span {
  padding: 10px 20px;
  cursor: pointer;
  color: #666;
  border-bottom: 2px solid transparent;
}

.login-type-tabs span.active {
  color: #667eea;
  border-bottom-color: #667eea;
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  color: #333;
  font-size: 14px;
}

.form-group input {
  width: 100%;
  padding: 12px 15px;
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
  transition: border-color 0.3s;
}

.form-group input:focus {
  border-color: #667eea;
  outline: none;
}

.form-group button {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #fff;
  border: none;
  border-radius: 5px;
  font-size: 16px;
  cursor: pointer;
  transition: opacity 0.3s;
}

.form-group button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.captcha-group .captcha-input {
  display: flex;
  gap: 10px;
}

.captcha-group .captcha-input input {
  flex: 1;
}

.captcha-group .send-btn {
  width: 120px;
  padding: 12px;
  background: #667eea;
  font-size: 14px;
}

.error-message {
  color: #f56c6c;
  font-size: 14px;
  text-align: center;
  margin-top: 10px;
}
</style>
```

#### 4.2.2 permission.js（权限指令）

```javascript
// src/directives/permission.js

import store from '@/store';

export const permission = {
  inserted(el, binding) {
    const { value } = binding;
    const permissions = store.getters.permissions || [];
    
    if (value instanceof Array) {
      const hasPermission = value.some(perm => permissions.includes(perm));
      if (!hasPermission) {
        el.parentNode && el.parentNode.removeChild(el);
      }
    } else {
      if (!permissions.includes(value)) {
        el.parentNode && el.parentNode.removeChild(el);
      }
    }
  }
};

export default {
  permission
};
```

#### 4.2.3 router.js（路由守卫）

```javascript
// src/router/index.js

import Vue from 'vue';
import VueRouter from 'vue-router';
import api from '@/services/api';

Vue.use(VueRouter);

const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/',
    component: () => import('@/views/layout/Layout.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: 'home',
        name: 'Home',
        component: () => import('@/views/home/Index.vue'),
        meta: { permission: 'home:view' }
      },
      {
        path: 'cases',
        name: 'Cases',
        component: () => import('@/views/cases/Index.vue'),
        meta: { permission: 'case:view' }
      },
      {
        path: 'cases/:id',
        name: 'CaseDetail',
        component: () => import('@/views/cases/Detail.vue'),
        meta: { permission: 'case:view' }
      },
      // 更多路由...
    ]
  },
  {
    path: '*',
    redirect: '/home'
  }
];

const router = new VueRouter({
  routes
});

// 路由守卫
router.beforeEach(async (to, from, next) => {
  const token = localStorage.getItem('accessToken');
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth !== false);
  
  if (requiresAuth && !token) {
    next('/login');
    return;
  }
  
  if (token && !localStorage.getItem('user')) {
    try {
      const result = await api.getCurrentUser();
      if (result.status === '1') {
        localStorage.setItem('user', JSON.stringify(result.data));
      } else {
        next('/login');
        return;
      }
    } catch (e) {
      next('/login');
      return;
    }
  }
  
  // 检查权限
  const requiredPermission = to.meta.permission;
  if (requiredPermission) {
    const permissions = JSON.parse(localStorage.getItem('permissions') || '[]');
    if (!permissions.includes(requiredPermission)) {
      next('/403');
      return;
    }
  }
  
  next();
});

export default router;
```

#### 4.2.4 store/index.js（状态管理）

```javascript
// src/store/index.js

import Vue from 'vue';
import Vuex from 'vuex';
import api from '@/services/api';

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    user: JSON.parse(localStorage.getItem('user') || 'null'),
    permissions: JSON.parse(localStorage.getItem('permissions') || '[]'),
    menus: JSON.parse(localStorage.getItem('menus') || '[]'),
    token: localStorage.getItem('accessToken')
  },
  
  getters: {
    user: state => state.user,
    permissions: state => state.permissions,
    menus: state => state.menus,
    isLoggedIn: state => !!state.token,
    hasPermission: state => permission => state.permissions.includes(permission)
  },
  
  mutations: {
    SET_USER(state, user) {
      state.user = user;
      localStorage.setItem('user', JSON.stringify(user));
    },
    SET_PERMISSIONS(state, permissions) {
      state.permissions = permissions;
      localStorage.setItem('permissions', JSON.stringify(permissions));
    },
    SET_MENUS(state, menus) {
      state.menus = menus;
      localStorage.setItem('menus', JSON.stringify(menus));
    },
    SET_TOKEN(state, token) {
      state.token = token;
      localStorage.setItem('accessToken', token);
    },
    LOGOUT(state) {
      state.user = null;
      state.permissions = [];
      state.menus = [];
      state.token = null;
      localStorage.removeItem('user');
      localStorage.removeItem('permissions');
      localStorage.removeItem('menus');
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
    }
  },
  
  actions: {
    async loadPermissions({ commit }) {
      try {
        const result = await api.getPermissions();
        if (result.status === '1') {
          commit('SET_PERMISSIONS', result.data.permissions);
          commit('SET_MENUS', result.data.menus);
        }
      } catch (e) {
        console.error('加载权限失败:', e);
      }
    },
    
    async logout({ commit }) {
      await api.logout();
      commit('LOGOUT');
    }
  }
});
```

### 4.3 React实现示例

#### 4.3.1 Login.jsx（登录组件）

```jsx
// src/pages/Login.jsx

import React, { useState } from 'react';
import { useHistory } from 'react-router-dom';
import api from '@/services/api';

const Login = () => {
  const history = useHistory();
  const [loginType, setLoginType] = useState('password');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  const [passwordForm, setPasswordForm] = useState({ username: '', password: '' });
  const [smsForm, setSmsForm] = useState({ mobile: '', code: '' });
  const [smsCountdown, setSmsCountdown] = useState(0);
  
  const handlePasswordLogin = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    
    try {
      const result = await api.login(passwordForm.username, passwordForm.password);
      
      if (result.success) {
        history.push('/home');
      } else {
        setError(result.message);
      }
    } catch (err) {
      setError('登录失败，请检查网络连接');
    } finally {
      setLoading(false);
    }
  };
  
  const sendSmsCode = async () => {
    if (!/^1[3-9]\d{9}$/.test(smsForm.mobile)) {
      setError('请输入正确的手机号');
      return;
    }
    
    try {
      const result = await api.sendLoginSms(smsForm.mobile);
      
      if (result.status === '1') {
        setSmsCountdown(60);
        const timer = setInterval(() => {
          setSmsCountdown(prev => {
            if (prev <= 1) {
              clearInterval(timer);
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
      } else {
        setError(result.msg);
      }
    } catch (err) {
      setError('验证码发送失败');
    }
  };
  
  const handleSmsLogin = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    
    try {
      const result = await api.loginBySms(smsForm.mobile, smsForm.code);
      
      if (result.success) {
        history.push('/home');
      } else {
        setError(result.message);
      }
    } catch (err) {
      setError('登录失败，请检查网络连接');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="login-container">
      <div className="login-box">
        <h2>法律案件管理系统</h2>
        
        <div className="login-type-tabs">
          <span 
            className={loginType === 'password' ? 'active' : ''}
            onClick={() => setLoginType('password')}
          >
            密码登录
          </span>
          <span 
            className={loginType === 'sms' ? 'active' : ''}
            onClick={() => setLoginType('sms')}
          >
            短信登录
          </span>
        </div>
        
        {loginType === 'password' ? (
          <form onSubmit={handlePasswordLogin}>
            <div className="form-group">
              <label>用户名</label>
              <input
                type="text"
                value={passwordForm.username}
                onChange={(e) => setPasswordForm({...passwordForm, username: e.target.value})}
                placeholder="请输入用户名"
                required
              />
            </div>
            
            <div className="form-group">
              <label>密码</label>
              <input
                type="password"
                value={passwordForm.password}
                onChange={(e) => setPasswordForm({...passwordForm, password: e.target.value})}
                placeholder="请输入密码"
                required
              />
            </div>
            
            <div className="form-group">
              <button type="submit" disabled={loading}>
                {loading ? '登录中...' : '登 录'}
              </button>
            </div>
          </form>
        ) : (
          <form onSubmit={handleSmsLogin}>
            <div className="form-group">
              <label>手机号</label>
              <input
                type="tel"
                value={smsForm.mobile}
                onChange={(e) => setSmsForm({...smsForm, mobile: e.target.value})}
                placeholder="请输入手机号"
                maxLength="11"
                required
              />
            </div>
            
            <div className="form-group captcha-group">
              <label>验证码</label>
              <div className="captcha-input">
                <input
                  type="text"
                  value={smsForm.code}
                  onChange={(e) => setSmsForm({...smsForm, code: e.target.value})}
                  placeholder="请输入验证码"
                  maxLength="6"
                  required
                />
                <button 
                  type="button"
                  onClick={sendSmsCode}
                  disabled={smsCountdown > 0}
                >
                  {smsCountdown > 0 ? `${smsCountdown}s后重发` : '获取验证码'}
                </button>
              </div>
            </div>
            
            <div className="form-group">
              <button type="submit" disabled={loading}>
                {loading ? '登录中...' : '登 录'}
              </button>
            </div>
          </form>
        )}
        
        {error && <div className="error-message">{error}</div>}
      </div>
    </div>
  );
};

export default Login;
```

---

## 五、API接口文档

### 5.1 认证接口

#### 5.1.1 用户名密码登录

**POST** `/api/web/login`

**请求参数**：
```json
{
  "username": "admin",
  "password": "admin123",
  "deviceId": "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx",
  "deviceInfo": "{\"deviceId\":\"xxx\",\"browser\":\"Chrome\",\"os\":\"Windows\"}"
}
```

**成功响应**：
```json
{
  "status": "1",
  "msg": "登录成功",
  "data": {
    "accessToken": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9...",
    "accessTokenExpire": 900000,
    "refreshToken": "a1b2c3d4e5f6...",
    "refreshTokenExpire": 604800000,
    "user": {
      "uPid": 1,
      "uUser": "admin",
      "uName": "管理员",
      "uDept": "技术部",
      "uTel": "13800138000",
      "uMobile": "13800138000",
      "uEmail": "admin@example.com"
    }
  }
}
```

**失败响应**：
```json
{
  "status": "0",
  "msg": "用户名或密码错误",
  "data": null
}
```

#### 5.1.2 发送登录验证码

**POST** `/api/web/sendLoginSms`

**请求参数**：
```json
{
  "mobile": "13800138000"
}
```

**成功响应**：
```json
{
  "status": "1",
  "msg": "验证码发送成功",
  "data": null
}
```

#### 5.1.3 手机验证码登录

**POST** `/api/web/loginBySms`

**请求参数**：
```json
{
  "mobile": "13800138000",
  "smsCode": "123456",
  "deviceId": "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx",
  "deviceInfo": "{\"deviceId\":\"xxx\",\"browser\":\"Chrome\",\"os\":\"Windows\"}"
}
```

**响应格式**同用户名密码登录。

#### 5.1.4 刷新令牌

**POST** `/api/web/refreshToken`

**请求参数**：
```json
{
  "refreshToken": "a1b2c3d4e5f6...",
  "deviceId": "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
}
```

**成功响应**：
```json
{
  "status": "1",
  "msg": "令牌刷新成功",
  "data": {
    "accessToken": "new_access_token...",
    "accessTokenExpire": 900000,
    "refreshToken": "new_refresh_token...",
    "refreshTokenExpire": 604800000
  }
}
```

#### 5.1.5 登出

**POST** `/api/web/logout`

**请求头**：
```
Authorization: Bearer <accessToken>
```

**请求参数**：
```json
{
  "refreshToken": "a1b2c3d4e5f6..."
}
```

**成功响应**：
```json
{
  "status": "1",
  "msg": "登出成功",
  "data": null
}
```

#### 5.1.6 获取当前用户信息

**GET** `/api/web/currentUser`

**请求头**：
```
Authorization: Bearer <accessToken>
```

**成功响应**：
```json
{
  "status": "1",
  "msg": "获取成功",
  "data": {
    "uPid": 1,
    "uUser": "admin",
    "uName": "管理员",
    "uDept": "技术部",
    "uTel": "13800138000",
    "uMobile": "13800138000",
    "uEmail": "admin@example.com"
  }
}
```

#### 5.1.7 获取权限信息

**GET** `/api/web/permissions`

**请求头**：
```
Authorization: Bearer <accessToken>
```

**成功响应**：
```json
{
  "status": "1",
  "msg": "获取成功",
  "data": {
    "permissions": ["case:view", "case:add", "case:edit", "case:delete"],
    "menus": [
      {
        "permId": 1,
        "permCode": "home",
        "permName": "首页",
        "permType": "1",
        "path": "/home",
        "component": "home/Index",
        "icon": "home",
        "children": []
      },
      {
        "permId": 2,
        "permCode": "case",
        "permName": "案件管理",
        "permType": "1",
        "path": "/cases",
        "component": "cases/Index",
        "icon": "folder",
        "children": [
          {
            "permId": 3,
            "permCode": "case:view",
            "permName": "查看案件",
            "permType": "2"
          }
        ]
      }
    ]
  }
}
```

---

## 六、安全机制详解

### 6.1 登录失败锁定

- 同一账号连续失败5次，锁定15分钟
- 同一IP连续失败5次，锁定15分钟
- 使用Redis计数，自动过期

### 6.2 双令牌机制

- Access Token：15分钟有效，用于API请求
- Refresh Token：7天有效，用于换取新的Access Token
- Refresh Token存储在数据库，可主动失效

### 6.3 设备绑定（可选）

- 用户可绑定可信设备
- 新设备登录需要短信验证
- 支持设备解绑

### 6.4 风险检测

- 异地登录检测（基于IP归属地）
- 新设备登录检测
- 登录异常行为分析

### 6.5 传输安全

- HTTPS加密传输
- 敏感信息脱敏
- 请求签名验证（可选）

---

## 七、部署注意事项

### 7.1 阿里云短信配置

```properties
# 在阿里云控制台创建AccessKey
# 创建短信服务，获取SignName和TemplateCode
aliyun.sms.access-key-id=your-access-key-id
aliyun.sms.access-key-secret=your-access-key-secret
aliyun.sms.sign-name=法律案件管理系统
aliyun.sms.template-code.login=SMS_123456789
```

### 7.2 Redis配置

```properties
# 确保Redis服务正常运行
spring.redis.host=localhost
spring.redis.port=6379
# 如有密码则配置
spring.redis.password=your-password
```

### 7.3 JWT密钥

```properties
# 使用足够长度的密钥（至少512位）
jwt.secret=your-256-bit-or-longer-secret-key-here
```

### 7.4 数据库初始化

1. 执行建表SQL
2. 初始化系统角色
3. 初始化系统配置

---

## 八、总结

本方案实现了完整的登录与权限控制体系，包括：

1. **多种登录方式**：用户名密码登录、手机验证码登录
2. **双令牌机制**：解决JWT过期问题，提升用户体验
3. **安全增强**：登录失败锁定、设备绑定、风险检测
4. **统一权限中心**：RBAC权限模型，支持细粒度权限控制
5. **SSO扩展**：统一认证接口预留

方案采用成熟的技术栈，实现简洁，安全可靠，可直接应用于生产环境。
